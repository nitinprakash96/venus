["^ ","~:output",["^ ","~:js","goog.provide('com.fulcrologic.fulcro.algorithms.merge');\n/**\n * Removes an ident, if it exists, from a list of idents in app state. This\n *   function is safe to use within mutations.\n */\ncom.fulcrologic.fulcro.algorithms.merge.remove_ident_STAR_ = (function com$fulcrologic$fulcro$algorithms$merge$remove_ident_STAR_(state_map,ident,path_to_idents){\nif(cljs.core.map_QMARK_(state_map)){\n} else {\nthrow (new Error(\"Assert failed: (map? state-map)\"));\n}\n\nvar new_list = (function (old_list){\nreturn cljs.core.vec(cljs.core.filter.cljs$core$IFn$_invoke$arity$2((function (p1__55882_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(ident,p1__55882_SHARP_);\n}),old_list));\n});\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$3(state_map,path_to_idents,new_list);\n});\n/**\n * Check the given keyword to see if it is in the :ui namespace.\n */\ncom.fulcrologic.fulcro.algorithms.merge.is_ui_query_fragment_QMARK_ = (function com$fulcrologic$fulcro$algorithms$merge$is_ui_query_fragment_QMARK_(kw){\nvar kw__$1 = ((cljs.core.map_QMARK_(kw))?cljs.core.first(cljs.core.keys(kw)):kw);\nif((kw__$1 instanceof cljs.core.Keyword)){\nvar G__55901 = kw__$1;\nvar G__55901__$1 = (((G__55901 == null))?null:cljs.core.namespace(G__55901));\nif((G__55901__$1 == null)){\nreturn null;\n} else {\nreturn cljs.core.re_find(/^ui(?:\\.|$)/,G__55901__$1);\n}\n} else {\nreturn null;\n}\n});\n/**\n * Returns true if the `k` in `props` is the sweep-merge not-found marker. This marker appears\n *   *during* merge, and can affect `:pre-merge` processing, since the data-tree will have these\n *   markers when the given data is missing.\n */\ncom.fulcrologic.fulcro.algorithms.merge.not_found_QMARK_ = (function com$fulcrologic$fulcro$algorithms$merge$not_found_QMARK_(props,k){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),cljs.core.get.cljs$core$IFn$_invoke$arity$2(props,k));\n});\n/**\n * Given x, return x value unless it's ::not-found (the mark/sweep missing marker), in which case it returns nil.\n * \n *   This is useful when you are pre-processing a tree that has been marked for missing data sweep (see `mark-missing`),\n *   but has not yet been swept. This is basically the same as a `nil?` check in this circumstance since the given\n *   value will be removed after the final sweep.\n */\ncom.fulcrologic.fulcro.algorithms.merge.nilify_not_found = (function com$fulcrologic$fulcro$algorithms$merge$nilify_not_found(x){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437))){\nreturn null;\n} else {\nreturn x;\n}\n});\n/**\n * Returns `data` with meta-data that marks it as a leaf in the result.\n */\ncom.fulcrologic.fulcro.algorithms.merge.as_leaf = (function com$fulcrologic$fulcro$algorithms$merge$as_leaf(data){\nif(cljs.core.coll_QMARK_(data)){\nreturn cljs.core.with_meta(data,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"fulcro\",\"leaf\",\"fulcro/leaf\",-2094500471),true], null));\n} else {\nreturn data;\n}\n});\n/**\n * Returns true iff the given data is marked as a leaf in the result (according to the query). Requires pre-marking.\n */\ncom.fulcrologic.fulcro.algorithms.merge.leaf_QMARK_ = (function com$fulcrologic$fulcro$algorithms$merge$leaf_QMARK_(data){\nreturn (((!(cljs.core.coll_QMARK_(data)))) || (((((cljs.core.vector_QMARK_(data)) && (cljs.core.empty_QMARK_(data)))) || (((cljs.core.coll_QMARK_(data)) && (cljs.core.boolean$(new cljs.core.Keyword(\"fulcro\",\"leaf\",\"fulcro/leaf\",-2094500471).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(data)))))))));\n});\n/**\n * Turn a union query into a query that attempts to encompass all possible things that might be queried.\n */\ncom.fulcrologic.fulcro.algorithms.merge.union__GT_query = (function com$fulcrologic$fulcro$algorithms$merge$union__GT_query(union_query){\nreturn cljs.core.vec(cljs.core.set(cljs.core.flatten(cljs.core.vals(union_query))));\n});\ncom.fulcrologic.fulcro.algorithms.merge.mark_missing_impl = (function com$fulcrologic$fulcro$algorithms$merge$mark_missing_impl(result,query){\nvar missing_entity = cljs.core.PersistentArrayMap.EMPTY;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (result__$1,element){\nvar element__$1 = ((cljs.core.list_QMARK_(element))?cljs.core.first(element):element\n);\nvar join_QMARK_ = com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(element__$1);\nvar jk = ((join_QMARK_)?com.fulcrologic.fulcro.algorithms.do_not_use.join_key(element__$1):null);\nvar result_key = (((element__$1 instanceof cljs.core.Keyword))?element__$1:((join_QMARK_)?jk:null\n));\nvar result_value = cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,result_key);\nvar ident_element_QMARK_ = edn_query_language.core.ident_QMARK_(element__$1);\nif(((((ident_element_QMARK_) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Symbol(null,\"_\",\"_\",-1201019570,null),cljs.core.second(element__$1))))) || (((edn_query_language.core.ident_QMARK_(result_key)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Symbol(null,\"_\",\"_\",-1201019570,null),cljs.core.second(result_key))))))){\nreturn result__$1;\n} else {\nif(cljs.core.truth_(com.fulcrologic.fulcro.algorithms.merge.is_ui_query_fragment_QMARK_(result_key))){\nreturn result__$1;\n} else {\nif((((element__$1 instanceof cljs.core.Keyword)) && ((cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,element__$1) == null)))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,element__$1,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\n} else {\nif(((join_QMARK_) && (((typeof com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1) === 'number') || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Symbol(null,\"...\",\"...\",-1926939749,null),com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1))))))){\nvar result_SINGLEQUOTE_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,jk);\nif((result_SINGLEQUOTE_ == null)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,jk,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\n} else {\nif(cljs.core.vector_QMARK_(result_SINGLEQUOTE_)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,jk,cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (item){\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2(item,query) : com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.call(null,item,query));\n}),result_SINGLEQUOTE_));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,jk,(com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2(result_SINGLEQUOTE_,query) : com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.call(null,result_SINGLEQUOTE_,query)));\n\n}\n}\n} else {\nif(((ident_element_QMARK_) && ((cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,element__$1) == null)))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,element__$1,missing_entity);\n} else {\nif(com.fulcrologic.fulcro.algorithms.do_not_use.union_QMARK_(element__$1)){\nvar v = cljs.core.get.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\nvar to_one_QMARK_ = cljs.core.map_QMARK_(v);\nvar to_many_QMARK_ = cljs.core.vector_QMARK_(v);\nvar wide_query = com.fulcrologic.fulcro.algorithms.merge.union__GT_query(com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1));\nif(to_one_QMARK_){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,(com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2(v,wide_query) : com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.call(null,v,wide_query)));\n} else {\nif(to_many_QMARK_){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (i){\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2(i,wide_query) : com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.call(null,i,wide_query));\n}),v));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),v)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\n} else {\nreturn result__$1;\n\n}\n}\n}\n} else {\nif(((join_QMARK_) && (((edn_query_language.core.ident_QMARK_(jk)) && ((cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,jk) == null)))))){\nvar mock_missing_object = (function (){var G__55923 = cljs.core.PersistentArrayMap.EMPTY;\nvar G__55924 = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1);\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2(G__55923,G__55924) : com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.call(null,G__55923,G__55924));\n})();\nvar v = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([mock_missing_object,missing_entity], 0));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,jk,v);\n} else {\nif(((join_QMARK_) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),cljs.core.get.cljs$core$IFn$_invoke$arity$3(result__$1,jk,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437)))))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,jk,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437));\n} else {\nif(((join_QMARK_) && (cljs.core.vector_QMARK_(cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,jk))))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,jk,cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (item){\nvar G__55932 = item;\nvar G__55933 = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1);\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2(G__55932,G__55933) : com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.call(null,G__55932,G__55933));\n}),cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,jk)));\n} else {\nif(((join_QMARK_) && (cljs.core.map_QMARK_(cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,jk))))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,jk,(function (){var G__55935 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(result__$1,jk);\nvar G__55936 = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1);\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2(G__55935,G__55936) : com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.call(null,G__55935,G__55936));\n})());\n} else {\nif(((join_QMARK_) && (((cljs.core.vector_QMARK_(com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1))) && ((!(((cljs.core.map_QMARK_(result_value)) || (cljs.core.vector_QMARK_(result_value)))))))))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,(function (){var G__55939 = cljs.core.PersistentArrayMap.EMPTY;\nvar G__55940 = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(element__$1);\nreturn (com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2 ? com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.cljs$core$IFn$_invoke$arity$2(G__55939,G__55940) : com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl.call(null,G__55939,G__55940));\n})());\n} else {\nif(cljs.core.truth_(result_key)){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(result__$1,result_key,com.fulcrologic.fulcro.algorithms.merge.as_leaf);\n} else {\nreturn result__$1;\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}),result,query);\n});\n/**\n * Recursively walk the query and response marking anything that was *asked for* in the query but is *not* in the response as missing.\n *   The sweep-merge process (which happens later in the plumbing) uses these markers as indicators to remove any existing\n *   data in the target of the merge (i.e. your state database).\n * \n *   The naive approach to data merging (even recursive) would fail to remove such data.\n * \n *   Returns the result with missing markers in place (which are then used/removed in a later stage).\n * \n *   See the Developer Guide section on Fulcro's merge process for more information.\n */\ncom.fulcrologic.fulcro.algorithms.merge.mark_missing = (function com$fulcrologic$fulcro$algorithms$merge$mark_missing(result,query){\ntry{return com.fulcrologic.fulcro.algorithms.merge.mark_missing_impl(result,query);\n}catch (e55946){var e = e55946;\ntaoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10(taoensso.timbre._STAR_config_STAR_,new cljs.core.Keyword(null,\"error\",\"error\",-978969032),\"com.fulcrologic.fulcro.algorithms.merge\",null,163,new cljs.core.Keyword(null,\"p\",\"p\",151049309),new cljs.core.Keyword(null,\"auto\",\"auto\",-566279492),(new cljs.core.Delay((function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [e,\"Unable to mark missing on result. Returning unmarked result\"], null);\n}),null)),null,951481617);\n\nreturn result;\n}});\n/**\n * Remove not-found keys from m (non-recursive). `m` can be a map (sweep the values) or vector (run sweep-one on each entry).\n */\ncom.fulcrologic.fulcro.algorithms.merge.sweep_one = (function com$fulcrologic$fulcro$algorithms$merge$sweep_one(m){\nif((((!(com.fulcrologic.fulcro.algorithms.tempid.tempid_QMARK_(m)))) && (cljs.core.map_QMARK_(m)))){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (acc,p__55948){\nvar vec__55951 = p__55948;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55951,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55951,(1),null);\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),k)) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),v)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"tempids\",\"tempids\",1767509089),k)))))){\nreturn acc;\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,k,v);\n}\n}),cljs.core.with_meta(cljs.core.PersistentArrayMap.EMPTY,cljs.core.meta(m)),m);\n} else {\nif(cljs.core.vector_QMARK_(m)){\nreturn cljs.core.with_meta(cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(com.fulcrologic.fulcro.algorithms.merge.sweep_one,m),cljs.core.meta(m));\n} else {\nreturn m;\n\n}\n}\n});\n/**\n * Remove all of the not-found keys (recursively) from m, stopping at marked leaves (if present). Requires `m`\n *   to have been pre-marked via `mark-missing`.\n */\ncom.fulcrologic.fulcro.algorithms.merge.sweep = (function com$fulcrologic$fulcro$algorithms$merge$sweep(m){\nif(com.fulcrologic.fulcro.algorithms.merge.leaf_QMARK_(m)){\nreturn com.fulcrologic.fulcro.algorithms.merge.sweep_one(m);\n} else {\nif((((!(com.fulcrologic.fulcro.algorithms.tempid.tempid_QMARK_(m)))) && (cljs.core.map_QMARK_(m)))){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (acc,p__55957){\nvar vec__55958 = p__55957;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55958,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55958,(1),null);\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),k)) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),v)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"tempids\",\"tempids\",1767509089),k)))))){\nreturn acc;\n} else {\nif(((edn_query_language.core.ident_QMARK_(v)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),cljs.core.second(v))))){\nreturn acc;\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,k,(com.fulcrologic.fulcro.algorithms.merge.sweep.cljs$core$IFn$_invoke$arity$1 ? com.fulcrologic.fulcro.algorithms.merge.sweep.cljs$core$IFn$_invoke$arity$1(v) : com.fulcrologic.fulcro.algorithms.merge.sweep.call(null,v)));\n\n}\n}\n}),cljs.core.with_meta(cljs.core.PersistentArrayMap.EMPTY,cljs.core.meta(m)),m);\n} else {\nif(cljs.core.vector_QMARK_(m)){\nreturn cljs.core.with_meta(cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(com.fulcrologic.fulcro.algorithms.merge.sweep,m),cljs.core.meta(m));\n} else {\nreturn m;\n\n}\n}\n}\n});\n/**\n * Do a recursive merge of source into target (both maps), but remove any target data that is marked as missing in the response.\n * \n *   Requires that the `source` has been marked via `mark-missing`.\n * \n *   The missing marker is generated in the source when something has been asked for in the query, but had no value in the\n *   response. This allows us to correctly remove 'empty' data from the database without accidentally removing something\n *   that may still exist on the server (in truth we don't know its status, since it wasn't asked for, but we leave\n *   it as our 'best guess').\n */\ncom.fulcrologic.fulcro.algorithms.merge.sweep_merge = (function com$fulcrologic$fulcro$algorithms$merge$sweep_merge(target,source){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (acc,p__55972){\nvar vec__55973 = p__55972;\nvar key = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55973,(0),null);\nvar new_value = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55973,(1),null);\nvar existing_value = cljs.core.get.cljs$core$IFn$_invoke$arity$2(acc,key);\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(key,new cljs.core.Keyword(null,\"tempids\",\"tempids\",1767509089))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(key,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437))))){\nreturn acc;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new_value,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437))){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(acc,key);\n} else {\nif(((edn_query_language.core.ident_QMARK_(new_value)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"not-found\",\"com.fulcrologic.fulcro.algorithms.merge/not-found\",190673437),cljs.core.second(new_value))))){\nreturn acc;\n} else {\nif(com.fulcrologic.fulcro.algorithms.merge.leaf_QMARK_(new_value)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,key,com.fulcrologic.fulcro.algorithms.merge.sweep_one(new_value));\n} else {\nif(((cljs.core.map_QMARK_(existing_value)) && (cljs.core.map_QMARK_(new_value)))){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(acc,key,com.fulcrologic.fulcro.algorithms.merge.sweep_merge,new_value);\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,key,com.fulcrologic.fulcro.algorithms.merge.sweep(new_value));\n\n}\n}\n}\n}\n}\n}),target,source);\n});\ncom.fulcrologic.fulcro.algorithms.merge.component_pre_merge = (function com$fulcrologic$fulcro$algorithms$merge$component_pre_merge(class$,query,state,data,options){\nif(com.fulcrologic.fulcro.components.has_pre_merge_QMARK_(class$)){\nvar entity = (function (){var G__55980 = com.fulcrologic.fulcro.components.get_ident.cljs$core$IFn$_invoke$arity$2(class$,data);\nif((G__55980 == null)){\nreturn null;\n} else {\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(state,G__55980);\n}\n})();\nvar result = com.fulcrologic.fulcro.components.pre_merge(class$,new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"state-map\",\"state-map\",-1313872128),state,new cljs.core.Keyword(null,\"current-normalized\",\"current-normalized\",851723724),entity,new cljs.core.Keyword(null,\"data-tree\",\"data-tree\",1311167582),data,new cljs.core.Keyword(null,\"query\",\"query\",-1288509510),query], null));\nreturn result;\n} else {\nreturn data;\n}\n});\n/**\n * Transform function that modifies data using component pre-merge hook.\n */\ncom.fulcrologic.fulcro.algorithms.merge.pre_merge_transform = (function com$fulcrologic$fulcro$algorithms$merge$pre_merge_transform(var_args){\nvar G__55982 = arguments.length;\nswitch (G__55982) {\ncase 1:\nreturn com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$1 = (function (state){\nreturn com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2(state,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2 = (function (state,options){\nreturn (function com$fulcrologic$fulcro$algorithms$merge$pre_merge_transform_internal(query,data){\nvar temp__5751__auto__ = new cljs.core.Keyword(null,\"component\",\"component\",1555936782).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(query));\nif(cljs.core.truth_(temp__5751__auto__)){\nvar class$ = temp__5751__auto__;\nreturn com.fulcrologic.fulcro.algorithms.merge.component_pre_merge(class$,query,state,data,options);\n} else {\nreturn data;\n}\n});\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$lang$maxFixedArity = 2);\n\n/**\n * Merge all of the mutations that were joined with a query.\n * \n *   The options currently do nothing. If you want mark/sweep, pre-mark the data-tree with `merge/mark-missing`,\n *   and this function will sweep the result.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins = (function com$fulcrologic$fulcro$algorithms$merge$merge_mutation_joins(var_args){\nvar G__55986 = arguments.length;\nswitch (G__55986) {\ncase 3:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$3 = (function (state,query,data_tree){\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$4(state,query,data_tree,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$4 = (function (state,query,data_tree,options){\nif(cljs.core.map_QMARK_(data_tree)){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (updated_state,query_element){\nvar k = (function (){var and__4210__auto__ = com.fulcrologic.fulcro.algorithms.do_not_use.mutation_join_QMARK_(query_element);\nif(and__4210__auto__){\nreturn com.fulcrologic.fulcro.algorithms.do_not_use.join_key(query_element);\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar subtree = cljs.core.get.cljs$core$IFn$_invoke$arity$2(data_tree,k);\nif(cljs.core.truth_((function (){var and__4210__auto__ = k;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn subtree;\n} else {\nreturn and__4210__auto__;\n}\n})())){\nvar subquery = com.fulcrologic.fulcro.algorithms.do_not_use.join_value(query_element);\nvar target = new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.data-targeting\",\"target\",\"com.fulcrologic.fulcro.algorithms.data-targeting/target\",-1540673140).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(subquery));\nvar idnt = new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"temporary-key\",\"com.fulcrologic.fulcro.algorithms.merge/temporary-key\",-1065335624);\nvar norm_query = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentArrayMap.createAsIfByAssoc([idnt,subquery])], null);\nvar norm_tree = cljs.core.PersistentArrayMap.createAsIfByAssoc([idnt,subtree]);\nvar db = com.fulcrologic.fulcro.algorithms.normalize.tree__GT_db.cljs$core$IFn$_invoke$arity$4(norm_query,norm_tree,true,com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2(state,options));\nvar G__56000 = com.fulcrologic.fulcro.algorithms.merge.sweep_merge(updated_state,db);\nvar G__56000__$1 = (cljs.core.truth_(target)?com.fulcrologic.fulcro.algorithms.data_targeting.process_target.cljs$core$IFn$_invoke$arity$3(G__56000,idnt,target):G__56000);\nif(cljs.core.not(target)){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(G__56000__$1,db,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([idnt], 0));\n} else {\nreturn G__56000__$1;\n}\n} else {\nreturn updated_state;\n}\n}),state,query);\n} else {\nreturn state;\n}\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$lang$maxFixedArity = 4);\n\ncom.fulcrologic.fulcro.algorithms.merge.merge_ident = (function com$fulcrologic$fulcro$algorithms$merge$merge_ident(app_state,ident,props){\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$4(app_state,ident,cljs.core.comp.cljs$core$IFn$_invoke$arity$2(com.fulcrologic.fulcro.algorithms.merge.sweep_one,cljs.core.merge),props);\n});\ncom.fulcrologic.fulcro.algorithms.merge.sift_idents = (function com$fulcrologic$fulcro$algorithms$merge$sift_idents(res){\nvar map__56007 = cljs.core.group_by((function (p1__56006_SHARP_){\nreturn cljs.core.vector_QMARK_(cljs.core.first(p1__56006_SHARP_));\n}),res);\nvar map__56007__$1 = cljs.core.__destructure_map(map__56007);\nvar idents = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56007__$1,true);\nvar rest = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56007__$1,false);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,idents),cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,rest)], null);\n});\n/**\n * Handle merging incoming data and sweep it of values that are marked missing. This function also ensures that raw\n * mutation join results are ignored (they must be merged via `merge-mutation-joins`).\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_tree = (function com$fulcrologic$fulcro$algorithms$merge$merge_tree(target,source){\nvar source_to_merge = cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentArrayMap.EMPTY,cljs.core.filter.cljs$core$IFn$_invoke$arity$1((function (p__56009){\nvar vec__56010 = p__56009;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56010,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56010,(1),null);\nreturn (!((k instanceof cljs.core.Symbol)));\n})),source);\nreturn com.fulcrologic.fulcro.algorithms.merge.sweep_merge(target,source_to_merge);\n});\n/**\n * Merge the given `refs` (a map from ident to props), query (a query that contains ident-joins), and tree:\n * \n *   returns a new tree with the data merged into the proper ident-based tables.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_idents = (function com$fulcrologic$fulcro$algorithms$merge$merge_idents(tree,query,refs,options){\nvar ident_joins = cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentArrayMap.EMPTY,cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$1((function (p1__56013_SHARP_){\nvar G__56017 = p1__56013_SHARP_;\nif(cljs.core.seq_QMARK_(p1__56013_SHARP_)){\nreturn cljs.core.first(G__56017);\n} else {\nreturn G__56017;\n}\n})),cljs.core.filter.cljs$core$IFn$_invoke$arity$1((function (p1__56014_SHARP_){\nreturn ((com.fulcrologic.fulcro.algorithms.do_not_use.join_QMARK_(p1__56014_SHARP_)) && (edn_query_language.core.ident_QMARK_(com.fulcrologic.fulcro.algorithms.do_not_use.join_key(p1__56014_SHARP_))));\n}))),query);\nvar step = (function com$fulcrologic$fulcro$algorithms$merge$merge_idents_$_step(result_tree,p__56025){\nvar vec__56026 = p__56025;\nvar ident = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56026,(0),null);\nvar props = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56026,(1),null);\nvar component_query = cljs.core.get.cljs$core$IFn$_invoke$arity$3(ident_joins,ident,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"*\",\"*\",345799209,null)], null));\nvar normalized_data = com.fulcrologic.fulcro.algorithms.normalize.tree__GT_db.cljs$core$IFn$_invoke$arity$4(component_query,props,false,com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2(tree,options));\nvar refs__$1 = cljs.core.meta(normalized_data);\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_tree(com.fulcrologic.fulcro.algorithms.merge.merge_ident(result_tree,ident,normalized_data),refs__$1);\n});\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(step,tree,refs);\n});\n/**\n * Merge the query-result of a query using Fulcro's standard merge and normalization logic.\n * \n *   Typically used on the state atom as:\n * \n *   ```\n *   (swap! state merge* query-result query)\n *   ```\n * \n *   - `state-map` - The normalized database.\n *   - `query` - The query that was used to obtain the query-result. This query will be treated relative to the root of the database.\n *   - `tree` - The query-result to merge (a map).\n * \n *   The options is currently doing nothing. If you want to sweep unreturned data use `merge/mark-missing` on your data tree\n *   before calling this.\n * \n *   See `merge-component` and `merge-component!` for possibly more appropriate functions for your task.\n * \n *   Returns the new normalized database.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_STAR_ = (function com$fulcrologic$fulcro$algorithms$merge$merge_STAR_(var_args){\nvar G__56030 = arguments.length;\nswitch (G__56030) {\ncase 3:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$3 = (function (state_map,query,result_tree){\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$4(state_map,query,result_tree,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$4 = (function (state_map,query,result_tree,options){\nvar vec__56031 = com.fulcrologic.fulcro.algorithms.merge.sift_idents(result_tree);\nvar idts = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56031,(0),null);\nvar result_tree__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56031,(1),null);\nvar normalized_result = com.fulcrologic.fulcro.algorithms.normalize.tree__GT_db.cljs$core$IFn$_invoke$arity$4(query,result_tree__$1,true,com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform.cljs$core$IFn$_invoke$arity$2(state_map,options));\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_tree(com.fulcrologic.fulcro.algorithms.merge.merge_idents(com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins.cljs$core$IFn$_invoke$arity$4(state_map,query,result_tree__$1,options),query,idts,options),normalized_result);\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$lang$maxFixedArity = 4);\n\n/**\n * Calculates the query that can be used to pull (or merge) a component with an ident\n *   to/from a normalized app database. Requires a tree of data that represents the instance of\n *   the component in question (e.g. ident will work on it)\n */\ncom.fulcrologic.fulcro.algorithms.merge.component_merge_query = (function com$fulcrologic$fulcro$algorithms$merge$component_merge_query(state_map,component,object_data){\nvar ident = com.fulcrologic.fulcro.components.ident(component,object_data);\nvar object_query = com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$2(component,state_map);\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentArrayMap.createAsIfByAssoc([ident,object_query])], null);\n});\n/**\n * Walks the given query and calls (merge-fn parent-union-component union-child-initial-state) for each non-default element of a union that has initial app state.\n *   You probably want to use merge-alternate-union-elements[!] on a state map or app.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_alternate_unions = (function com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions(merge_fn,root_component){\nvar walk_ast = (function() {\nvar com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast = null;\nvar com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__2 = (function (ast,visitor){\nreturn com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,null);\n});\nvar com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__3 = (function (p__56189,visitor,parent_union){\nvar map__56196 = p__56189;\nvar map__56196__$1 = cljs.core.__destructure_map(map__56196);\nvar parent_ast = map__56196__$1;\nvar children = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56196__$1,new cljs.core.Keyword(null,\"children\",\"children\",-940561982));\nvar component = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56196__$1,new cljs.core.Keyword(null,\"component\",\"component\",1555936782));\nvar type = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56196__$1,new cljs.core.Keyword(null,\"type\",\"type\",1174270348));\nvar dispatch_key = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56196__$1,new cljs.core.Keyword(null,\"dispatch-key\",\"dispatch-key\",733619510));\nvar union_key = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56196__$1,new cljs.core.Keyword(null,\"union-key\",\"union-key\",1529707234));\nvar key = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56196__$1,new cljs.core.Keyword(null,\"key\",\"key\",-1516042587));\nif(cljs.core.truth_((function (){var and__4210__auto__ = component;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = parent_union;\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"union-entry\",\"union-entry\",223335750),type);\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())){\n(visitor.cljs$core$IFn$_invoke$arity$2 ? visitor.cljs$core$IFn$_invoke$arity$2(component,parent_union) : visitor.call(null,component,parent_union));\n} else {\n}\n\nif(cljs.core.truth_(children)){\nvar seq__56218 = cljs.core.seq(children);\nvar chunk__56219 = null;\nvar count__56220 = (0);\nvar i__56221 = (0);\nwhile(true){\nif((i__56221 < count__56220)){\nvar ast = chunk__56219.cljs$core$IIndexed$_nth$arity$2(null,i__56221);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(ast),new cljs.core.Keyword(null,\"union\",\"union\",2142937499))){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,component);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(ast),new cljs.core.Keyword(null,\"union-entry\",\"union-entry\",223335750))){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,parent_union);\n} else {\nif(cljs.core.truth_(ast)){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,null);\n} else {\n}\n}\n}\n\n\nvar G__56407 = seq__56218;\nvar G__56408 = chunk__56219;\nvar G__56409 = count__56220;\nvar G__56410 = (i__56221 + (1));\nseq__56218 = G__56407;\nchunk__56219 = G__56408;\ncount__56220 = G__56409;\ni__56221 = G__56410;\ncontinue;\n} else {\nvar temp__5753__auto__ = cljs.core.seq(seq__56218);\nif(temp__5753__auto__){\nvar seq__56218__$1 = temp__5753__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__56218__$1)){\nvar c__4638__auto__ = cljs.core.chunk_first(seq__56218__$1);\nvar G__56411 = cljs.core.chunk_rest(seq__56218__$1);\nvar G__56412 = c__4638__auto__;\nvar G__56413 = cljs.core.count(c__4638__auto__);\nvar G__56414 = (0);\nseq__56218 = G__56411;\nchunk__56219 = G__56412;\ncount__56220 = G__56413;\ni__56221 = G__56414;\ncontinue;\n} else {\nvar ast = cljs.core.first(seq__56218__$1);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(ast),new cljs.core.Keyword(null,\"union\",\"union\",2142937499))){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,component);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(ast),new cljs.core.Keyword(null,\"union-entry\",\"union-entry\",223335750))){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,parent_union);\n} else {\nif(cljs.core.truth_(ast)){\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3(ast,visitor,null);\n} else {\n}\n}\n}\n\n\nvar G__56417 = cljs.core.next(seq__56218__$1);\nvar G__56418 = null;\nvar G__56419 = (0);\nvar G__56420 = (0);\nseq__56218 = G__56417;\nchunk__56219 = G__56418;\ncount__56220 = G__56419;\ni__56221 = G__56420;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast = function(p__56189,visitor,parent_union){\nswitch(arguments.length){\ncase 2:\nreturn com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__2.call(this,p__56189,visitor);\ncase 3:\nreturn com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__3.call(this,p__56189,visitor,parent_union);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$2 = com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__2;\ncom$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast.cljs$core$IFn$_invoke$arity$3 = com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast__3;\nreturn com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast;\n})()\n;\nvar merge_union = (function com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_merge_union(component,parent_union){\nvar default_initial_state = (function (){var and__4210__auto__ = parent_union;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = com.fulcrologic.fulcro.components.has_initial_app_state_QMARK_(parent_union);\nif(and__4210__auto____$1){\nreturn com.fulcrologic.fulcro.components.get_initial_state.cljs$core$IFn$_invoke$arity$2(parent_union,cljs.core.PersistentArrayMap.EMPTY);\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar to_many_QMARK_ = cljs.core.vector_QMARK_(default_initial_state);\nvar component_initial_state = (function (){var and__4210__auto__ = component;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = com.fulcrologic.fulcro.components.has_initial_app_state_QMARK_(component);\nif(and__4210__auto____$1){\nreturn com.fulcrologic.fulcro.components.get_initial_state.cljs$core$IFn$_invoke$arity$2(component,cljs.core.PersistentArrayMap.EMPTY);\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_((function (){var and__4210__auto__ = component;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = component_initial_state;\nif(cljs.core.truth_(and__4210__auto____$1)){\nvar and__4210__auto____$2 = parent_union;\nif(cljs.core.truth_(and__4210__auto____$2)){\nreturn (((!(to_many_QMARK_))) && (cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(default_initial_state,component_initial_state)));\n} else {\nreturn and__4210__auto____$2;\n}\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn (merge_fn.cljs$core$IFn$_invoke$arity$2 ? merge_fn.cljs$core$IFn$_invoke$arity$2(parent_union,component_initial_state) : merge_fn.call(null,parent_union,component_initial_state));\n} else {\nreturn null;\n}\n});\nreturn walk_ast(edn_query_language.core.query__GT_ast(com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$1(root_component)),merge_union);\n});\n/**\n * Merge an arbitrary data-tree that conforms to the shape of the given query using Fulcro's\n *   standard merge and normalization logic.\n * \n *   app - A fulcro application to merge into.\n *   query - A query, derived from components, that can be used to normalized a tree of data.\n *   data-tree - A tree of data that matches the nested shape of query.\n * \n *   The options map currently does nothing. If you want to remove unreturned data use `merge/mark-missing` on the\n *   data tree before merging and a sweep will automatically be done.\n * \n *   NOTE: This function assumes you are merging against the root of the tree. See\n *   `merge-component` and `merge-component!` for relative merging.\n * \n *   See also `merge*`.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_BANG_ = (function com$fulcrologic$fulcro$algorithms$merge$merge_BANG_(var_args){\nvar G__56262 = arguments.length;\nswitch (G__56262) {\ncase 3:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (app,data_tree,query){\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$4(app,data_tree,query,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$core$IFn$_invoke$arity$4 = (function (app,data_tree,query,options){\nvar map__56267 = com.fulcrologic.fulcro.components.any__GT_app(app);\nvar map__56267__$1 = cljs.core.__destructure_map(map__56267);\nvar state_atom = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56267__$1,new cljs.core.Keyword(\"com.fulcrologic.fulcro.application\",\"state-atom\",\"com.fulcrologic.fulcro.application/state-atom\",648128366));\nif(cljs.core.truth_(state_atom)){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$variadic(state_atom,com.fulcrologic.fulcro.algorithms.merge.merge_STAR_,query,data_tree,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([options], 0));\n} else {\nreturn null;\n}\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_BANG_.cljs$lang$maxFixedArity = 4);\n\n/**\n * Given a state map of the application database, a component, and a tree of component-data: normalizes\n * the tree of data and merges the component table entries into the state, returning a new state map.\n * \n * Since there is not an implied root, the component itself won't be linked into your graph (though it will\n * remain correctly linked for its own consistency).\n * \n * * `state-map` - The normalized database\n * * `component` - A component class\n * * `component-data` - A tree of data that matches the shape of the component's query.\n * * `named-parameters` - Parameters from `targeting/integrate-ident*` that will let you link the merged component into the graph.\n * Named parameters may also include `:remove-missing?`, which will remove things that are queried for but do\n * not appear in the data from the state.\n * \n * See also targeting/integrate-ident*, and merge/merge-component!\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_component = (function com$fulcrologic$fulcro$algorithms$merge$merge_component(var_args){\nvar args__4824__auto__ = [];\nvar len__4818__auto___56437 = arguments.length;\nvar i__4819__auto___56438 = (0);\nwhile(true){\nif((i__4819__auto___56438 < len__4818__auto___56437)){\nargs__4824__auto__.push((arguments[i__4819__auto___56438]));\n\nvar G__56439 = (i__4819__auto___56438 + (1));\ni__4819__auto___56438 = G__56439;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4825__auto__ = ((((3) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((3)),(0),null)):null);\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_component.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4825__auto__);\n});\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_component.cljs$core$IFn$_invoke$arity$variadic = (function (state_map,component,component_data,named_parameters){\nif(com.fulcrologic.fulcro.components.has_ident_QMARK_(component)){\nvar options = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,named_parameters);\nvar map__56277 = options;\nvar map__56277__$1 = cljs.core.__destructure_map(map__56277);\nvar remove_missing_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56277__$1,new cljs.core.Keyword(null,\"remove-missing?\",\"remove-missing?\",-2044119224));\nvar query = com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$2(component,state_map);\nvar marked_data = (cljs.core.truth_(remove_missing_QMARK_)?com.fulcrologic.fulcro.algorithms.merge.mark_missing(component_data,query):component_data);\nvar updated_state = com.fulcrologic.fulcro.algorithms.merge.merge_STAR_.cljs$core$IFn$_invoke$arity$4(state_map,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"merge\",\"com.fulcrologic.fulcro.algorithms.merge/merge\",1176000440),query], null)], null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"merge\",\"com.fulcrologic.fulcro.algorithms.merge/merge\",1176000440),marked_data], null),options);\nvar real_ident = cljs.core.get.cljs$core$IFn$_invoke$arity$2(updated_state,new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"merge\",\"com.fulcrologic.fulcro.algorithms.merge/merge\",1176000440));\nvar integrate_params = cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic((function (p__56283){\nvar vec__56288 = p__56283;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56288,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56288,(1),null);\nif(cljs.core.truth_((function (){var fexpr__56291 = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"replace\",\"replace\",-786587770),null,new cljs.core.Keyword(null,\"prepend\",\"prepend\",342616040),null,new cljs.core.Keyword(null,\"append\",\"append\",-291298229),null], null), null);\nreturn (fexpr__56291.cljs$core$IFn$_invoke$arity$1 ? fexpr__56291.cljs$core$IFn$_invoke$arity$1(k) : fexpr__56291.call(null,k));\n})())){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null);\n} else {\nreturn null;\n}\n}),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.partition.cljs$core$IFn$_invoke$arity$2((2),named_parameters)], 0));\nvar integrate_targets = (function (s){\nif(cljs.core.seq(named_parameters)){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(com.fulcrologic.fulcro.algorithms.data_targeting.integrate_ident_STAR_,s,real_ident,integrate_params);\n} else {\nreturn s;\n}\n});\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(integrate_targets(updated_state),new cljs.core.Keyword(\"com.fulcrologic.fulcro.algorithms.merge\",\"merge\",\"com.fulcrologic.fulcro.algorithms.merge/merge\",1176000440));\n} else {\ntaoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10(taoensso.timbre._STAR_config_STAR_,new cljs.core.Keyword(null,\"error\",\"error\",-978969032),\"com.fulcrologic.fulcro.algorithms.merge\",null,425,new cljs.core.Keyword(null,\"p\",\"p\",151049309),new cljs.core.Keyword(null,\"auto\",\"auto\",-566279492),(new cljs.core.Delay((function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"Cannot merge component \",component,\" because it does not have an ident!\"], null);\n}),null)),null,-1440883738);\n\nreturn state_map;\n}\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_component.cljs$lang$maxFixedArity = (3));\n\n/** @this {Function} */\n(com.fulcrologic.fulcro.algorithms.merge.merge_component.cljs$lang$applyTo = (function (seq56273){\nvar G__56274 = cljs.core.first(seq56273);\nvar seq56273__$1 = cljs.core.next(seq56273);\nvar G__56275 = cljs.core.first(seq56273__$1);\nvar seq56273__$2 = cljs.core.next(seq56273__$1);\nvar G__56276 = cljs.core.first(seq56273__$2);\nvar seq56273__$3 = cljs.core.next(seq56273__$2);\nvar self__4805__auto__ = this;\nreturn self__4805__auto__.cljs$core$IFn$_invoke$arity$variadic(G__56274,G__56275,G__56276,seq56273__$3);\n}));\n\n/**\n * Normalize and merge a (sub)tree of application state into the application using a known UI component's query and ident.\n * \n *   This utility function obtains the ident of the incoming object-data using the UI component's ident function. Once obtained,\n *   it uses the component's query and ident to normalize the data and places the resulting objects in the correct tables.\n *   It is also quite common to want those new objects to be linked into lists in other spots in app state, so this function\n *   supports optional named parameters for doing this. These named parameters can be repeated as many times as you like in order\n *   to place the ident of the new object into other data structures of app state.\n * \n *   This function honors the data merge story for Fulcro: attributes that are queried for but do not appear in the\n *   data will be removed from the application. This function also uses the initial state for the component as a base\n *   for merge if there was no state for the object already in the database.\n * \n *   This function will also trigger re-renders of components that directly render object merged, as well as any components\n *   into which you integrate that data via the named-parameters.\n * \n *   This function is primarily meant to be used from things like server push and setTimeout/setInterval, where you're outside\n *   of the normal mutation story. Do not use this function within abstract mutations.\n * \n *   * `app`: Your application.\n *   * `component`: The class of the component that corresponds to the data. Must have an ident.\n *   * `object-data`: A map (tree) of data to merge. Will be normalized for you.\n *   * `named-parameter`: Post-processing ident integration steps. see `targeting/integrate-ident*`. You may also\n *   include `:remove-missing? true/false` to indicate that data that is missing for the component's query\n *   should be removed from app state.\n * \n *   Any keywords that appear in ident integration steps will be added to the re-render queue.\n * \n *   See also `fulcro.client.primitives/merge!`.\n *   \n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_ = (function com$fulcrologic$fulcro$algorithms$merge$merge_component_BANG_(var_args){\nvar args__4824__auto__ = [];\nvar len__4818__auto___56445 = arguments.length;\nvar i__4819__auto___56446 = (0);\nwhile(true){\nif((i__4819__auto___56446 < len__4818__auto___56445)){\nargs__4824__auto__.push((arguments[i__4819__auto___56446]));\n\nvar G__56447 = (i__4819__auto___56446 + (1));\ni__4819__auto___56446 = G__56447;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4825__auto__ = ((((3) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((3)),(0),null)):null);\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4825__auto__);\n});\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (app,component,object_data,named_parameters){\nvar temp__5753__auto__ = com.fulcrologic.fulcro.components.any__GT_app(app);\nif(cljs.core.truth_(temp__5753__auto__)){\nvar app__$1 = temp__5753__auto__;\nif((!(com.fulcrologic.fulcro.components.has_ident_QMARK_(component)))){\nreturn taoensso.timbre._log_BANG_.cljs$core$IFn$_invoke$arity$10(taoensso.timbre._STAR_config_STAR_,new cljs.core.Keyword(null,\"error\",\"error\",-978969032),\"com.fulcrologic.fulcro.algorithms.merge\",null,461,new cljs.core.Keyword(null,\"p\",\"p\",151049309),new cljs.core.Keyword(null,\"auto\",\"auto\",-566279492),(new cljs.core.Delay((function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"merge-component!: component must implement Ident. Merge skipped.\"], null);\n}),null)),null,-475318798);\n} else {\nvar state = new cljs.core.Keyword(\"com.fulcrologic.fulcro.application\",\"state-atom\",\"com.fulcrologic.fulcro.application/state-atom\",648128366).cljs$core$IFn$_invoke$arity$1(app__$1);\nvar render_BANG_ = com.fulcrologic.fulcro.algorithms.lookup.app_algorithm(app__$1,new cljs.core.Keyword(null,\"schedule-render!\",\"schedule-render!\",2095050350));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(state,(function (s){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(com.fulcrologic.fulcro.algorithms.merge.merge_component,s,component,object_data,named_parameters);\n}));\n\nvar G__56304 = app__$1;\nvar G__56305 = cljs.core.PersistentArrayMap.EMPTY;\nreturn (render_BANG_.cljs$core$IFn$_invoke$arity$2 ? render_BANG_.cljs$core$IFn$_invoke$arity$2(G__56304,G__56305) : render_BANG_.call(null,G__56304,G__56305));\n}\n} else {\nreturn null;\n}\n}));\n\n(com.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_.cljs$lang$maxFixedArity = (3));\n\n/** @this {Function} */\n(com.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_.cljs$lang$applyTo = (function (seq56294){\nvar G__56295 = cljs.core.first(seq56294);\nvar seq56294__$1 = cljs.core.next(seq56294);\nvar G__56296 = cljs.core.first(seq56294__$1);\nvar seq56294__$2 = cljs.core.next(seq56294__$1);\nvar G__56297 = cljs.core.first(seq56294__$2);\nvar seq56294__$3 = cljs.core.next(seq56294__$2);\nvar self__4805__auto__ = this;\nreturn self__4805__auto__.cljs$core$IFn$_invoke$arity$variadic(G__56295,G__56296,G__56297,seq56294__$3);\n}));\n\n/**\n * Just like merge-alternate-union-elements!, but usable from within mutations and on server-side rendering. Ensures\n *   that when a component has initial state it will end up in the state map, even if it isn't currently in the\n *   initial state of the union component (which can only point to one at a time).\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_alternate_union_elements = (function com$fulcrologic$fulcro$algorithms$merge$merge_alternate_union_elements(state_map,root_component){\nvar state_map_atom = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(state_map);\nvar merge_to_state = (function (comp,tree){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(state_map_atom,com.fulcrologic.fulcro.algorithms.merge.merge_component,comp,tree);\n});\nvar _ = com.fulcrologic.fulcro.algorithms.merge.merge_alternate_unions(merge_to_state,root_component);\nvar new_state = cljs.core.deref(state_map_atom);\nreturn new_state;\n});\n/**\n * Walks the query and initial state of root-component and merges the alternate sides of unions with initial state into\n *   the application state database. See also `merge-alternate-union-elements`, which can be used on a state map and\n *   is handy for server-side rendering. This function side-effects on your app, and returns nothing.\n */\ncom.fulcrologic.fulcro.algorithms.merge.merge_alternate_union_elements_BANG_ = (function com$fulcrologic$fulcro$algorithms$merge$merge_alternate_union_elements_BANG_(app,root_component){\nvar app__$1 = com.fulcrologic.fulcro.components.any__GT_app(app);\nreturn com.fulcrologic.fulcro.algorithms.merge.merge_alternate_unions(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(com.fulcrologic.fulcro.algorithms.merge.merge_component_BANG_,app__$1),root_component);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","Various algorithms that are used for merging trees of data into a normalized Fulcro database.","~:file","com/fulcrologic/fulcro/algorithms/merge.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",44],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.core.async","~$cljs.core.async"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$com.fulcrologic.fulcro.algorithms.merge","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$ah","~$com.fulcrologic.fulcro.algorithms.lookup","~$edn-query-language.core","^Q","~$com.fulcrologic.fulcro.algorithms.normalize","^R","~$log","~$taoensso.timbre","~$targeting","~$com.fulcrologic.fulcro.algorithms.data-targeting","~$comp","~$com.fulcrologic.fulcro.components","~$eql","^Q","~$com.fulcrologic.fulcro.algorithms.denormalize","^Z","~$fnorm","^R","~$cljs.core","^10","~$goog","^11","^V","^V","~$com.fulcrologic.fulcro.algorithms.tempid","^12","~$util","~$com.fulcrologic.fulcro.algorithms.do-not-use","^P","^P","^X","^X","^T","^T","~$fdn","^Z","~$tempid","^12","^14","^14"],"~:seen",["^G",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^10","^10","^S","^T","^W","^X","^X","^X","^T","^T"],"~:form",["~#list",["~$ns","^I","Various algorithms that are used for merging trees of data into a normalized Fulcro database.",["^1<",["^18",["^V","~:as","^U"],["^X","^1>","^W"],["^P","^1>","^O"],["^R","^1>","^["],["^Z","^1>","^15"],["^14","^1>","^13"],["^Q","^1>","^Y"],["^T","^1>","^S"],["^12","^1>","^16"]]]]],"~:flags",["^ ","^18",["^G",[]]],"~:js-deps",["^ "],"~:deps",["^11","^10","^V","^X","^P","^R","^Z","^14","^Q","^T","^12"]],"^L","^I","~:resource-id",["~:shadow.build.classpath/resource","com/fulcrologic/fulcro/algorithms/merge.cljc"],"~:compiled-at",1636231901181,"^J",["^ ","^O","^P","^Q","^Q","^R","^R","^S","^T","^U","^V","^W","^X","^Y","^Q","^Z","^Z","^[","^R","^10","^10","^11","^11","^V","^V","^12","^12","^13","^14","^P","^P","^X","^X","^T","^T","^15","^Z","^16","^12","^14","^14"],"~:resource-name","com/fulcrologic/fulcro/algorithms/merge.cljc","~:warnings",[],"~:source","(ns com.fulcrologic.fulcro.algorithms.merge\n  \"Various algorithms that are used for merging trees of data into a normalized Fulcro database.\"\n  (:require\n    [com.fulcrologic.fulcro.algorithms.data-targeting :as targeting]\n    [com.fulcrologic.fulcro.components :as comp]\n    [com.fulcrologic.fulcro.algorithms.lookup :as ah]\n    [com.fulcrologic.fulcro.algorithms.normalize :as fnorm]\n    [com.fulcrologic.fulcro.algorithms.denormalize :as fdn]\n    [com.fulcrologic.fulcro.algorithms.do-not-use :as util]\n    [edn-query-language.core :as eql]\n    [taoensso.timbre :as log]\n    [com.fulcrologic.fulcro.algorithms.tempid :as tempid]))\n\n(defn remove-ident*\n  \"Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations.\"\n  [state-map ident path-to-idents]\n  {:pre [(map? state-map)]}\n  (let [new-list (fn [old-list]\n                   (vec (filter #(not= ident %) old-list)))]\n    (update-in state-map path-to-idents new-list)))\n\n(defn is-ui-query-fragment?\n  \"Check the given keyword to see if it is in the :ui namespace.\"\n  [kw]\n  (let [kw (if (map? kw) (-> kw keys first) kw)]\n    (when (keyword? kw) (some->> kw namespace (re-find #\"^ui(?:\\.|$)\")))))\n\n(defn not-found?\n  \"Returns true if the `k` in `props` is the sweep-merge not-found marker. This marker appears\n  *during* merge, and can affect `:pre-merge` processing, since the data-tree will have these\n  markers when the given data is missing.\"\n  [props k]\n  (= ::not-found (get props k)))\n\n(defn nilify-not-found\n  \"Given x, return x value unless it's ::not-found (the mark/sweep missing marker), in which case it returns nil.\n\n  This is useful when you are pre-processing a tree that has been marked for missing data sweep (see `mark-missing`),\n  but has not yet been swept. This is basically the same as a `nil?` check in this circumstance since the given\n  value will be removed after the final sweep.\"\n  [x]\n  (if (= x ::not-found) nil x))\n\n(defn- as-leaf\n  \"Returns `data` with meta-data that marks it as a leaf in the result.\"\n  [data]\n  (if (coll? data)\n    (with-meta data {:fulcro/leaf true})\n    data))\n\n(defn- leaf?\n  \"Returns true iff the given data is marked as a leaf in the result (according to the query). Requires pre-marking.\"\n  [data]\n  (or\n    (not (coll? data))\n    (and (vector? data) (empty? data))\n    (and (coll? data)\n      (-> data meta :fulcro/leaf boolean))))\n\n(defn- union->query\n  \"Turn a union query into a query that attempts to encompass all possible things that might be queried.\"\n  [union-query]\n  (->> union-query vals flatten set vec))\n\n(defn mark-missing-impl\n  [result query]\n  (let [missing-entity {}]\n    (reduce (fn [result element]\n              (let [element        (cond\n                                     (list? element) (first element)\n                                     :else element)\n                    join?          (util/join? element)\n                    jk             (when join? (util/join-key element))\n                    result-key     (cond\n                                     (keyword? element) element\n                                     join? jk\n                                     :else nil)\n                    result-value   (get result result-key)\n                    ident-element? (eql/ident? element)]\n                (cond\n                  (or (and ident-element? (= '_ (second element)))\n                    (and (eql/ident? result-key) (= '_ (second result-key))))\n                  result\n\n                  (is-ui-query-fragment? result-key)\n                  result\n\n                  ; plain missing prop\n                  (and (keyword? element) (nil? (get result element)))\n                  (assoc result element ::not-found)\n\n                  ; recursion\n                  (and join? (or\n                               (number? (util/join-value element))\n                               (= '... (util/join-value element))))\n                  (let [result' (get result jk)]\n                    (cond\n                      (nil? result') (assoc result jk ::not-found)\n                      (vector? result') (assoc result jk (mapv (fn [item] (mark-missing-impl item query)) result'))\n                      :otherwise (assoc result jk (mark-missing-impl result' query))))\n\n                  ; pure ident query\n                  (and ident-element? (nil? (get result element)))\n                  (assoc result element missing-entity)\n\n                  ; union (a join with a map as a target query)\n                  (util/union? element)\n                  (let [v          (get result result-key ::not-found)\n                        to-one?    (map? v)\n                        to-many?   (vector? v)\n                        wide-query (union->query (util/join-value element))]\n                    (cond\n                      to-one? (assoc result result-key (mark-missing-impl v wide-query))\n                      to-many? (assoc result result-key (mapv (fn [i] (mark-missing-impl i wide-query)) v))\n                      (= ::not-found v) (assoc result result-key ::not-found)\n                      :else result))\n\n                  ; ident-based join to nothing (removing table entries)\n                  (and join?\n                    (eql/ident? jk)\n                    (nil? (get result jk)))\n                  (let [mock-missing-object (mark-missing-impl {} (util/join-value element))\n                        v                   (merge mock-missing-object missing-entity)]\n                    (assoc result jk v))\n\n                  ; join to nothing\n                  (and join? (= ::not-found (get result jk ::not-found)))\n                  (assoc result jk ::not-found)\n\n                  ; to-many join\n                  (and join? (vector? (get result jk)))\n                  (assoc result jk (mapv (fn [item] (mark-missing-impl item (util/join-value element))) (get result jk)))\n\n                  ; to-one join\n                  (and join? (map? (get result jk)))\n                  (assoc result jk (mark-missing-impl (get result jk) (util/join-value element)))\n\n                  ; join, but with a broken result (scalar instead of a map or vector)\n                  (and join? (vector? (util/join-value element)) (not (or (map? result-value) (vector? result-value))))\n                  (assoc result result-key (mark-missing-impl {} (util/join-value element)))\n\n                  ; prop we found, but not a further join...mark it as a leaf so sweep can stop early on it\n                  result-key\n                  (update result result-key as-leaf)\n\n                  :else result))) result query)))\n\n(defn mark-missing\n  \"Recursively walk the query and response marking anything that was *asked for* in the query but is *not* in the response as missing.\n  The sweep-merge process (which happens later in the plumbing) uses these markers as indicators to remove any existing\n  data in the target of the merge (i.e. your state database).\n\n  The naive approach to data merging (even recursive) would fail to remove such data.\n\n  Returns the result with missing markers in place (which are then used/removed in a later stage).\n\n  See the Developer Guide section on Fulcro's merge process for more information.\"\n  [result query]\n  (try\n    (mark-missing-impl result query)\n    (catch #?(:clj Exception :cljs :default) e\n      (log/error e \"Unable to mark missing on result. Returning unmarked result\")\n      result)))\n\n(defn- sweep-one\n  \"Remove not-found keys from m (non-recursive). `m` can be a map (sweep the values) or vector (run sweep-one on each entry).\"\n  [m]\n  (cond\n    ;; tempids look like maps in CLJ\n    (and (not (tempid/tempid? m)) (map? m))\n    (reduce (fn [acc [k v]]\n              (if (or (= ::not-found k) (= ::not-found v) (= :tempids k))\n                acc\n                (assoc acc k v)))\n      (with-meta {} (meta m)) m)\n    (vector? m) (with-meta (mapv sweep-one m) (meta m))\n    :else m))\n\n(defn sweep\n  \"Remove all of the not-found keys (recursively) from m, stopping at marked leaves (if present). Requires `m`\n  to have been pre-marked via `mark-missing`.\"\n  [m]\n  (cond\n    (leaf? m) (sweep-one m)\n    ;; tempids look like maps in CLJ\n    (and (not (tempid/tempid? m)) (map? m))\n    (reduce (fn [acc [k v]]\n              (cond\n                (or (= ::not-found k) (= ::not-found v) (= :tempids k)) acc\n                (and (eql/ident? v) (= ::not-found (second v))) acc\n                :otherwise (assoc acc k (sweep v))))\n      (with-meta {} (meta m))\n      m)\n    (vector? m) (with-meta (mapv sweep m) (meta m))\n    :else m))\n\n(defn sweep-merge\n  \"Do a recursive merge of source into target (both maps), but remove any target data that is marked as missing in the response.\n\n  Requires that the `source` has been marked via `mark-missing`.\n\n  The missing marker is generated in the source when something has been asked for in the query, but had no value in the\n  response. This allows us to correctly remove 'empty' data from the database without accidentally removing something\n  that may still exist on the server (in truth we don't know its status, since it wasn't asked for, but we leave\n  it as our 'best guess').\"\n  [target source]\n  (reduce\n    (fn [acc [key new-value]]\n      (let [existing-value (get acc key)]\n        (cond\n          (or (= key :tempids) (= key ::not-found)) acc\n          (= new-value ::not-found) (dissoc acc key)\n          (and (eql/ident? new-value) (= ::not-found (second new-value))) acc\n          (leaf? new-value) (assoc acc key (sweep-one new-value))\n          (and (map? existing-value) (map? new-value)) (update acc key sweep-merge new-value)\n          :else (assoc acc key (sweep new-value)))))\n    target\n    source))\n\n(defn- component-pre-merge [class query state data options]\n  (if (comp/has-pre-merge? class)\n    (let [entity (some->> (comp/get-ident class data) (get-in state))\n          result (comp/pre-merge class {:state-map          state\n                                        :current-normalized entity\n                                        :data-tree          data\n                                        :query              query})]\n      result)\n    data))\n\n(defn pre-merge-transform\n  \"Transform function that modifies data using component pre-merge hook.\"\n  ([state]\n   (pre-merge-transform state {}))\n  ([state options]\n   (fn pre-merge-transform-internal [query data]\n     (if-let [class (-> query meta :component)]\n       (component-pre-merge class query state data options)\n       data))))\n\n(defn merge-mutation-joins\n  \"Merge all of the mutations that were joined with a query.\n\n  The options currently do nothing. If you want mark/sweep, pre-mark the data-tree with `merge/mark-missing`,\n  and this function will sweep the result.\"\n  ([state query data-tree]\n   (merge-mutation-joins state query data-tree {}))\n  ([state query data-tree options]\n   (if (map? data-tree)\n     (reduce (fn [updated-state query-element]\n               (let [k       (and (util/mutation-join? query-element) (util/join-key query-element))\n                     subtree (get data-tree k)]\n                 (if (and k subtree)\n                   (let [subquery   (util/join-value query-element)\n                         target     (-> (meta subquery) ::targeting/target)\n                         idnt       ::temporary-key\n                         norm-query [{idnt subquery}]\n                         norm-tree  {idnt subtree}\n                         db         (fnorm/tree->db norm-query norm-tree true (pre-merge-transform state options))]\n                     (cond-> (sweep-merge updated-state db)\n                       target (targeting/process-target idnt target)\n                       (not target) (dissoc db idnt)))\n                   updated-state))) state query)\n     state)))\n\n(defn merge-ident [app-state ident props]\n  (update-in app-state ident (comp sweep-one merge) props))\n\n(defn- sift-idents [res]\n  (let [{idents true rest false} (group-by #(vector? (first %)) res)]\n    [(into {} idents) (into {} rest)]))\n\n(defn merge-tree\n  \"Handle merging incoming data and sweep it of values that are marked missing. This function also ensures that raw\n   mutation join results are ignored (they must be merged via `merge-mutation-joins`).\"\n  [target source]\n  (let [source-to-merge (into {}\n                          (filter (fn [[k _]] (not (symbol? k))))\n                          source)]\n    (sweep-merge target source-to-merge)))\n\n(defn merge-idents\n  \"Merge the given `refs` (a map from ident to props), query (a query that contains ident-joins), and tree:\n\n  returns a new tree with the data merged into the proper ident-based tables.\"\n  [tree query refs options]\n  (let [ident-joins (into {} (comp\n                               (map #(cond-> % (seq? %) first))\n                               (filter #(and (util/join? %)\n                                          (eql/ident? (util/join-key %)))))\n                      query)]\n    (letfn [(step [result-tree [ident props]]\n              (let [component-query (get ident-joins ident '[*])\n                    normalized-data (fnorm/tree->db component-query props false (pre-merge-transform tree options))\n                    refs            (meta normalized-data)]\n                (-> result-tree\n                  (merge-ident ident normalized-data)\n                  (merge-tree refs))))]\n      (reduce step tree refs))))\n\n(defn merge*\n  \"Merge the query-result of a query using Fulcro's standard merge and normalization logic.\n\n  Typically used on the state atom as:\n\n  ```\n  (swap! state merge* query-result query)\n  ```\n\n  - `state-map` - The normalized database.\n  - `query` - The query that was used to obtain the query-result. This query will be treated relative to the root of the database.\n  - `tree` - The query-result to merge (a map).\n\n  The options is currently doing nothing. If you want to sweep unreturned data use `merge/mark-missing` on your data tree\n  before calling this.\n\n  See `merge-component` and `merge-component!` for possibly more appropriate functions for your task.\n\n  Returns the new normalized database.\"\n  ([state-map query result-tree] (merge* state-map query result-tree {}))\n  ([state-map query result-tree options]\n   (let [[idts result-tree] (sift-idents result-tree)\n         normalized-result (fnorm/tree->db query result-tree true (pre-merge-transform state-map options))]\n     (-> state-map\n       (merge-mutation-joins query result-tree options)\n       (merge-idents query idts options)\n       (merge-tree normalized-result)))))\n\n(defn component-merge-query\n  \"Calculates the query that can be used to pull (or merge) a component with an ident\n  to/from a normalized app database. Requires a tree of data that represents the instance of\n  the component in question (e.g. ident will work on it)\"\n  [state-map component object-data]\n  (let [ident        (comp/ident component object-data)\n        object-query (comp/get-query component state-map)]\n    [{ident object-query}]))\n\n(defn merge-alternate-unions\n  \"Walks the given query and calls (merge-fn parent-union-component union-child-initial-state) for each non-default element of a union that has initial app state.\n  You probably want to use merge-alternate-union-elements[!] on a state map or app.\"\n  [merge-fn root-component]\n  (letfn [(walk-ast\n            ([ast visitor]\n             (walk-ast ast visitor nil))\n            ([{:keys [children component type dispatch-key union-key key] :as parent-ast} visitor parent-union]\n             (when (and component parent-union (= :union-entry type))\n               (visitor component parent-union))\n             (when children\n               (doseq [ast children]\n                 (cond\n                   (= (:type ast) :union) (walk-ast ast visitor component) ; the union's component is on the parent join\n                   (= (:type ast) :union-entry) (walk-ast ast visitor parent-union)\n                   ast (walk-ast ast visitor nil))))))\n          (merge-union [component parent-union]\n            (let [default-initial-state   (and parent-union (comp/has-initial-app-state? parent-union) (comp/get-initial-state parent-union {}))\n                  to-many?                (vector? default-initial-state)\n                  component-initial-state (and component (comp/has-initial-app-state? component) (comp/get-initial-state component {}))]\n              (when (and component component-initial-state parent-union (not to-many?) (not= default-initial-state component-initial-state))\n                (merge-fn parent-union component-initial-state))))]\n    (walk-ast\n      (eql/query->ast (comp/get-query root-component))\n      merge-union)))\n\n(defn merge!\n  \"Merge an arbitrary data-tree that conforms to the shape of the given query using Fulcro's\n  standard merge and normalization logic.\n\n  app - A fulcro application to merge into.\n  query - A query, derived from components, that can be used to normalized a tree of data.\n  data-tree - A tree of data that matches the nested shape of query.\n\n  The options map currently does nothing. If you want to remove unreturned data use `merge/mark-missing` on the\n  data tree before merging and a sweep will automatically be done.\n\n  NOTE: This function assumes you are merging against the root of the tree. See\n  `merge-component` and `merge-component!` for relative merging.\n\n  See also `merge*`.\"\n\n  ([app data-tree query]\n   (merge! app data-tree query {}))\n  ([app data-tree query options]\n   (let [{:com.fulcrologic.fulcro.application/keys [state-atom]} (comp/any->app app)]\n     (when state-atom\n       (swap! state-atom merge* query data-tree options)))))\n\n(defn merge-component\n  \"Given a state map of the application database, a component, and a tree of component-data: normalizes\n   the tree of data and merges the component table entries into the state, returning a new state map.\n\n   Since there is not an implied root, the component itself won't be linked into your graph (though it will\n   remain correctly linked for its own consistency).\n\n   * `state-map` - The normalized database\n   * `component` - A component class\n   * `component-data` - A tree of data that matches the shape of the component's query.\n   * `named-parameters` - Parameters from `targeting/integrate-ident*` that will let you link the merged component into the graph.\n   Named parameters may also include `:remove-missing?`, which will remove things that are queried for but do\n   not appear in the data from the state.\n\n   See also targeting/integrate-ident*, and merge/merge-component!\"\n  [state-map component component-data & named-parameters]\n  (if (comp/has-ident? component)\n    (let [options           (apply hash-map named-parameters)\n          {:keys [remove-missing?]} options\n          query             (comp/get-query component state-map)\n          marked-data       (if remove-missing?\n                              (mark-missing component-data query)\n                              component-data)\n          updated-state     (merge* state-map [{::merge query}] {::merge marked-data} options)\n          real-ident        (get updated-state ::merge)\n          integrate-params  (mapcat (fn [[k v]]\n                                      (if (#{:append :prepend :replace} k)\n                                        [k v]\n                                        nil))\n                              (partition 2 named-parameters))\n          integrate-targets (fn [s]\n                              (if (seq named-parameters)\n                                (apply targeting/integrate-ident* s real-ident integrate-params)\n                                s))]\n      (-> updated-state\n        (integrate-targets)\n        (dissoc ::merge)))\n    (do\n      (log/error \"Cannot merge component \" component \" because it does not have an ident!\")\n      state-map)))\n\n(defn merge-component!\n  \"Normalize and merge a (sub)tree of application state into the application using a known UI component's query and ident.\n\n  This utility function obtains the ident of the incoming object-data using the UI component's ident function. Once obtained,\n  it uses the component's query and ident to normalize the data and places the resulting objects in the correct tables.\n  It is also quite common to want those new objects to be linked into lists in other spots in app state, so this function\n  supports optional named parameters for doing this. These named parameters can be repeated as many times as you like in order\n  to place the ident of the new object into other data structures of app state.\n\n  This function honors the data merge story for Fulcro: attributes that are queried for but do not appear in the\n  data will be removed from the application. This function also uses the initial state for the component as a base\n  for merge if there was no state for the object already in the database.\n\n  This function will also trigger re-renders of components that directly render object merged, as well as any components\n  into which you integrate that data via the named-parameters.\n\n  This function is primarily meant to be used from things like server push and setTimeout/setInterval, where you're outside\n  of the normal mutation story. Do not use this function within abstract mutations.\n\n  * `app`: Your application.\n  * `component`: The class of the component that corresponds to the data. Must have an ident.\n  * `object-data`: A map (tree) of data to merge. Will be normalized for you.\n  * `named-parameter`: Post-processing ident integration steps. see `targeting/integrate-ident*`. You may also\n  include `:remove-missing? true/false` to indicate that data that is missing for the component's query\n  should be removed from app state.\n\n  Any keywords that appear in ident integration steps will be added to the re-render queue.\n\n  See also `fulcro.client.primitives/merge!`.\n  \"\n  [app component object-data & named-parameters]\n  (when-let [app (comp/any->app app)]\n    (if-not (comp/has-ident? component)\n      (log/error \"merge-component!: component must implement Ident. Merge skipped.\")\n      (let [state   (:com.fulcrologic.fulcro.application/state-atom app)\n            render! (ah/app-algorithm app :schedule-render!)]\n        (swap! state (fn [s] (apply merge-component s component object-data named-parameters)))\n        (render! app {})))))\n\n(defn merge-alternate-union-elements\n  \"Just like merge-alternate-union-elements!, but usable from within mutations and on server-side rendering. Ensures\n  that when a component has initial state it will end up in the state map, even if it isn't currently in the\n  initial state of the union component (which can only point to one at a time).\"\n  [state-map root-component]\n  (let [state-map-atom (atom state-map)\n        merge-to-state (fn [comp tree] (swap! state-map-atom merge-component comp tree))\n        _              (merge-alternate-unions merge-to-state root-component)\n        new-state      @state-map-atom]\n    new-state))\n\n(defn merge-alternate-union-elements!\n  \"Walks the query and initial state of root-component and merges the alternate sides of unions with initial state into\n  the application state database. See also `merge-alternate-union-elements`, which can be used on a state map and\n  is handy for server-side rendering. This function side-effects on your app, and returns nothing.\"\n  [app root-component]\n  (let [app (comp/any->app app)]\n    (merge-alternate-unions (partial merge-component! app) root-component)))\n\n","~:reader-features",["^G",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["js/Error","com.fulcrologic.fulcro.algorithms.merge/remove-ident*","state-map","ident","path-to-idents","cljs.core/map?","new-list","old-list","cljs.core/vec","p1__55882#","cljs.core.filter","cljs.core.not_EQ_","cljs.core.update_in","com.fulcrologic.fulcro.algorithms.merge/is-ui-query-fragment?","kw","cljs.core/keys","cljs.core/first","cljs.core/Keyword","G__55901","cljs.core/namespace","cljs.core/re-find","com.fulcrologic.fulcro.algorithms.merge/not-found?","props","k","cljs.core._EQ_","cljs.core.get","com.fulcrologic.fulcro.algorithms.merge/nilify-not-found","x","com.fulcrologic.fulcro.algorithms.merge/as-leaf","data","cljs.core/coll?","cljs.core/with-meta","com.fulcrologic.fulcro.algorithms.merge/leaf?","cljs.core/vector?","cljs.core/empty?","cljs.core/meta","cljs.core/boolean","com.fulcrologic.fulcro.algorithms.merge/union->query","union-query","cljs.core/vals","cljs.core/flatten","cljs.core/set","com.fulcrologic.fulcro.algorithms.merge/mark-missing-impl","result","query","missing-entity","cljs.core.reduce","element","cljs.core/list?","join?","com.fulcrologic.fulcro.algorithms.do-not-use/join?","jk","com.fulcrologic.fulcro.algorithms.do-not-use/join-key","result-key","result-value","ident-element?","edn-query-language.core/ident?","cljs.core/second","cljs.core.assoc","com.fulcrologic.fulcro.algorithms.do-not-use/join-value","result'","cljs.core.mapv","item","com.fulcrologic.fulcro.algorithms.do-not-use/union?","v","to-one?","to-many?","wide-query","i","mock-missing-object","G__55923","G__55924","cljs.core.merge","G__55932","G__55933","G__55935","G__55936","G__55939","G__55940","cljs.core.update","com.fulcrologic.fulcro.algorithms.merge/mark-missing","e55946","e","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","com.fulcrologic.fulcro.algorithms.merge/sweep-one","m","com.fulcrologic.fulcro.algorithms.tempid/tempid?","p__55948","vec__55951","cljs.core.nth","acc","com.fulcrologic.fulcro.algorithms.merge/sweep","p__55957","vec__55958","com.fulcrologic.fulcro.algorithms.merge/sweep-merge","target","source","p__55972","vec__55973","key","new-value","existing-value","cljs.core.dissoc","com.fulcrologic.fulcro.algorithms.merge/component-pre-merge","class","state","options","com.fulcrologic.fulcro.components/has-pre-merge?","entity","G__55980","com.fulcrologic.fulcro.components.get_ident","cljs.core.get_in","com.fulcrologic.fulcro.components/pre-merge","var_args","G__55982","com.fulcrologic.fulcro.algorithms.merge/pre-merge-transform","com.fulcrologic.fulcro.algorithms.merge.pre_merge_transform","temp__5751__auto__","G__55986","com.fulcrologic.fulcro.algorithms.merge/merge-mutation-joins","data-tree","com.fulcrologic.fulcro.algorithms.merge.merge_mutation_joins","updated-state","query-element","and__4210__auto__","com.fulcrologic.fulcro.algorithms.do-not-use/mutation-join?","subtree","subquery","idnt","norm-query","norm-tree","db","com.fulcrologic.fulcro.algorithms.normalize.tree__GT_db","G__56000","com.fulcrologic.fulcro.algorithms.data_targeting.process_target","cljs.core/not","com.fulcrologic.fulcro.algorithms.merge/merge-ident","app-state","cljs.core.comp","cljs.core/merge","com.fulcrologic.fulcro.algorithms.merge/sift-idents","res","map__56007","cljs.core/--destructure-map","idents","rest","p1__56006#","cljs.core/group-by","cljs.core.into","com.fulcrologic.fulcro.algorithms.merge/merge-tree","source-to-merge","p__56009","vec__56010","_","cljs.core/Symbol","com.fulcrologic.fulcro.algorithms.merge/merge-idents","tree","refs","ident-joins","p1__56013#","cljs.core.map","G__56017","cljs.core/seq?","p1__56014#","p__56025","vec__56026","result-tree","component-query","normalized-data","step","G__56030","com.fulcrologic.fulcro.algorithms.merge/merge*","com.fulcrologic.fulcro.algorithms.merge.merge_STAR_","vec__56031","idts","normalized-result","com.fulcrologic.fulcro.algorithms.merge/component-merge-query","component","object-data","com.fulcrologic.fulcro.components/ident","object-query","com.fulcrologic.fulcro.components.get_query","com.fulcrologic.fulcro.algorithms.merge/merge-alternate-unions","merge-fn","root-component","p__56189","map__56196","ast","visitor","com$fulcrologic$fulcro$algorithms$merge$merge_alternate_unions_$_walk_ast","children","type","dispatch-key","union-key","parent-ast","parent-union","seq__56218","cljs.core/seq","chunk__56219","count__56220","i__56221","temp__5753__auto__","cljs.core/chunked-seq?","c__4638__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/next","default-initial-state","com.fulcrologic.fulcro.components/has-initial-app-state?","com.fulcrologic.fulcro.components.get_initial_state","component-initial-state","walk-ast","edn-query-language.core/query->ast","merge-union","G__56262","com.fulcrologic.fulcro.algorithms.merge/merge!","app","com.fulcrologic.fulcro.algorithms.merge.merge_BANG_","map__56267","state-atom","com.fulcrologic.fulcro.components/any->app","cljs.core.swap_BANG_","args__4824__auto__","len__4818__auto__","i__4819__auto__","argseq__4825__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.algorithms.merge/merge-component","seq56273","G__56274","G__56275","G__56276","self__4805__auto__","component-data","named-parameters","com.fulcrologic.fulcro.components/has-ident?","map__56277","cljs.core.apply","cljs.core/hash-map","remove-missing?","marked-data","real-ident","integrate-params","cljs.core.mapcat","p__56283","vec__56288","fexpr__56291","cljs.core.partition","integrate-targets","s","com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","com.fulcrologic.fulcro.algorithms.merge/merge-component!","seq56294","G__56295","G__56296","G__56297","render!","com.fulcrologic.fulcro.algorithms.lookup/app-algorithm","G__56304","G__56305","com.fulcrologic.fulcro.algorithms.merge/merge-alternate-union-elements","cljs.core/deref","state-map-atom","cljs.core.atom","merge-to-state","comp","new-state","com.fulcrologic.fulcro.algorithms.merge/merge-alternate-union-elements!","cljs.core.partial"]],"~:used-vars",["^G",["~$com.fulcrologic.fulcro.algorithms.merge/sweep","~$com.fulcrologic.fulcro.algorithms.merge/mark-missing","~$cljs.core/mapcat","~$cljs.core/--destructure-map","~$com.fulcrologic.fulcro.algorithms.merge/nilify-not-found","~$com.fulcrologic.fulcro.algorithms.data-targeting/process-target","~$cljs.core/comp","~$com.fulcrologic.fulcro.algorithms.merge/merge-component","~$edn-query-language.core/query->ast","~$com.fulcrologic.fulcro.algorithms.do-not-use/join?","~$com.fulcrologic.fulcro.algorithms.merge/component-merge-query","~$cljs.core/vector?","~$cljs.core/filter","~$cljs.core/=","~$cljs.core/keys","~$cljs.core/partial","~$com.fulcrologic.fulcro.algorithms.merge/is-ui-query-fragment?","~$taoensso.timbre/-log!","~$com.fulcrologic.fulcro.algorithms.merge/merge-alternate-union-elements","~$cljs.core/IndexedSeq","~$edn-query-language.core/ident?","~$cljs.core/count","~$cljs.core/deref","~$com.fulcrologic.fulcro.components/has-ident?","~$cljs.core/hash-map","~$cljs.core/reduce","~$cljs.core/seq","~$cljs.core/chunk-first","~$com.fulcrologic.fulcro.algorithms.merge/merge-tree","~$cljs.core/apply","~$cljs.core/Keyword","~$cljs.core/group-by","~$cljs.core/mapv","~$cljs.core/not=","~$com.fulcrologic.fulcro.algorithms.merge/not-found?","~$cljs.core/dissoc","~$cljs.core/Delay","~$cljs.core/chunk-rest","~$cljs.core/atom","~$com.fulcrologic.fulcro.algorithms.merge/merge-ident","~$com.fulcrologic.fulcro.algorithms.do-not-use/mutation-join?","~$cljs.core/set","~$com.fulcrologic.fulcro.components/pre-merge","~$cljs.core/empty?","~$cljs.core/into","~$cljs.core/map?","~$com.fulcrologic.fulcro.components/get-ident","~$taoensso.timbre/*config*","~$cljs.core/update","~$com.fulcrologic.fulcro.algorithms.do-not-use/join-value","~$com.fulcrologic.fulcro.algorithms.merge/merge-alternate-union-elements!","~$cljs.core/with-meta","~$cljs.core/namespace","~$cljs.core/map","~$com.fulcrologic.fulcro.algorithms.do-not-use/union?","~$cljs.core/get-in","~$com.fulcrologic.fulcro.algorithms.merge/merge-mutation-joins","~$cljs.core/vals","~$cljs.core/swap!","~$com.fulcrologic.fulcro.algorithms.merge/sweep-one","~$com.fulcrologic.fulcro.algorithms.merge/merge-component!","~$com.fulcrologic.fulcro.algorithms.merge/sift-idents","~$cljs.core/get","~$com.fulcrologic.fulcro.algorithms.merge/union->query","~$com.fulcrologic.fulcro.components/get-initial-state","~$cljs.core/flatten","~$cljs.core/-nth","~$cljs.core/partition","~$com.fulcrologic.fulcro.algorithms.merge/as-leaf","~$com.fulcrologic.fulcro.components/has-pre-merge?","~$com.fulcrologic.fulcro.algorithms.merge/pre-merge-transform","~$cljs.core/re-find","~$com.fulcrologic.fulcro.algorithms.normalize/tree->db","~$com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","~$com.fulcrologic.fulcro.components/any->app","~$cljs.core/nth","~$cljs.core/meta","~$cljs.core/list?","~$cljs.core/second","~$cljs.core/next","~$cljs.core/vec","~$com.fulcrologic.fulcro.algorithms.tempid/tempid?","~$com.fulcrologic.fulcro.components/get-query","~$com.fulcrologic.fulcro.algorithms.merge/leaf?","~$com.fulcrologic.fulcro.algorithms.merge/mark-missing-impl","~$cljs.core/not","~$com.fulcrologic.fulcro.algorithms.lookup/app-algorithm","~$com.fulcrologic.fulcro.algorithms.merge/sweep-merge","~$cljs.core/assoc","~$com.fulcrologic.fulcro.algorithms.merge/remove-ident*","~$com.fulcrologic.fulcro.algorithms.merge/merge-alternate-unions","~$cljs.core/Symbol","~$cljs.core/coll?","~$com.fulcrologic.fulcro.algorithms.merge/merge*","~$com.fulcrologic.fulcro.algorithms.merge/merge-idents","~$com.fulcrologic.fulcro.components/ident","~$com.fulcrologic.fulcro.algorithms.merge/component-pre-merge","~$cljs.core/first","~$cljs.core/seq?","~$com.fulcrologic.fulcro.algorithms.merge/merge!","~$cljs.core/merge","~$cljs.core/update-in","~$com.fulcrologic.fulcro.components/has-initial-app-state?","~$com.fulcrologic.fulcro.algorithms.do-not-use/join-key","~$js/Error","~$cljs.core/boolean","~$cljs.core/chunked-seq?"]]],"~:cache-keys",["~#cmap",[["^1C","com/fulcrologic/fulcro/algorithms/normalize.cljc"],["1caf5ece14d08c1a1f2d6dbda6366e56e941c356","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^G",[]],"~:deps-syms",["^11","^10","^14","^Q","^T","^X"]]],["^1C","goog/dom/tagname.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.dom.HtmlElement"]]],["^1C","goog/async/freelist.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/labs/useragent/platform.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.labs.userAgent.util","~$goog.string"]]],["^1C","expound/util.cljc"],["f84ecd45aeef38fd6f1c53d8323e6abc5dc5a0e4","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10"]]],["^1C","goog/crypt/crypt.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.array","~$goog.asserts"]]],["^1C","goog/timer/timer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.Promise","~$goog.events.EventTarget","~$goog.Thenable"]]],["^1C","com/fulcrologic/fulcro/algorithms/lookup.cljc"],["1caf5ece14d08c1a1f2d6dbda6366e56e941c356","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^T"]]],["^1C","cljs/spec/gen/alpha.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","~$goog.Uri"]]],["^1C","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","~$clojure.string","^4>"]]],["^1C","goog/math/math.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4@"]]],["^1C","goog/html/trustedtypes.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/string/stringformat.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4>"]]],["^1C","goog/events/eventtype.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.events.BrowserFeature","~$goog.userAgent"]]],["^1C","goog/labs/useragent/browser.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4=","~$goog.object","~$goog.string.internal"]]],["^1C","goog/html/safeurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^4I"]]],["^1C","goog/array/array.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@"]]],["^1C","com/fulcrologic/fulcro/algorithms/do_not_use.cljc"],["1caf5ece14d08c1a1f2d6dbda6366e56e941c356","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^T","^4E","^Q","^4H","~$goog.crypt","~$goog.crypt.base64","^B"]]],["^1C","expound/problems.cljc"],["f84ecd45aeef38fd6f1c53d8323e6abc5dc5a0e4","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","~$expound.paths","^B"]]],["^1C","goog/useragent/useragent.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.labs.userAgent.browser","~$goog.labs.userAgent.engine","~$goog.labs.userAgent.platform","^4=","~$goog.reflect","^4>"]]],["^1C","goog/structs/prioritypool.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.structs.Pool","~$goog.structs.PriorityQueue"]]],["^1C","goog/async/run.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.async.WorkQueue","~$goog.async.nextTick","~$goog.async.throwException"]]],["^1C","taoensso/encore.cljs"],["19e6b7df8d479139a889d03eb0612d0b7a326998","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4E","~$clojure.set","~$cljs.reader","~$cljs.tools.reader.edn","^4H","^4>","~$goog.string.format","~$goog.string.StringBuffer","~$goog.events","~$goog.net.XhrIo","~$goog.net.XhrIoPool","~$goog.Uri.QueryData","~$goog.net.EventType","~$goog.net.ErrorCode","~$taoensso.truss"]]],["^1C","goog/debug/error.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/async/workqueue.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","~$goog.async.FreeList"]]],["^1C","goog/events/events.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","~$goog.debug.entryPointRegistry","~$goog.events.BrowserEvent","^4F","~$goog.events.Listenable","~$goog.events.ListenerMap","~$goog.debug.ErrorHandler","~$goog.events.EventId","~$goog.events.EventLike","~$goog.events.EventWrapper","~$goog.events.ListenableKey","~$goog.events.Listener"]]],["^1C","goog/promise/resolver.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4A"]]],["^1C","goog/events/browserfeature.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4G"]]],["^1C","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","~$cljs.tools.reader.impl.errors","~$cljs.tools.reader.reader-types","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader","^4>","^54"]]],["^1C","goog/structs/priorityqueue.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.structs.Heap"]]],["^1C","goog/net/xhrio.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.Timer","^4?","^4@","^5=","^4B","~$goog.json.hybrid","~$goog.log","^5:","^59","~$goog.net.HttpStatus","~$goog.net.XmlHttp","^4H","^4>","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","^4G","^4D","^5A","~$goog.net.XhrLike","~$goog.net.XmlHttpFactory"]]],["^1C","goog/promise/thenable.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4A"]]],["^1C","goog/dom/nodetype.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10"]]],["^1C","cljs/pprint.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4E","^4>","^54"]]],["^1C","com/fulcrologic/fulcro/algorithms/data_targeting.cljc"],["1caf5ece14d08c1a1f2d6dbda6366e56e941c356","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^B","^50","~$com.fulcrologic.guardrails.core","^T","^Q"]]],["^1C","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^5H","^5I","^5J","^5G","^4?","^4>","^54"]]],["^1C","expound/alpha.cljc"],["f84ecd45aeef38fd6f1c53d8323e6abc5dc5a0e4","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","~$expound.problems","^B","^4E","^50","~$expound.printer","~$expound.util","~$expound.ansi"]]],["^1C","goog/net/wrapperxmlhttpfactory.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^5U","^5V"]]],["^1C","goog/events/eventtarget.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.Disposable","^4@","^55","~$goog.events.Event","^5?","^5@","^4H","^5B","^5C","^5E"]]],["^1C","com/fulcrologic/guardrails/core.cljc"],["fea1142983ea044a9d4139a04fb7599e98df5174","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4E","^T","^B","~$expound.alpha"]]],["^1C","goog/disposable/disposable.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.disposable.IDisposable"]]],["^1C","expound/ansi.cljc"],["f84ecd45aeef38fd6f1c53d8323e6abc5dc5a0e4","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4E"]]],["^1C","goog/string/typedstring.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["~:shadow.build.npm/resource","node_modules/react/index.js"],["e8091a4577ab6b32c9fa13d5dfc59db052218e1e","4e9614cdc0e2c223ef717009a8fd70c2c8df01cc","a69a7f3d4a4636bf9035bc53c05b2d99a7b8af7f","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["~$shadow.js","~$module$node_modules$react$cjs$react_production_min","~$module$node_modules$react$cjs$react_development"]]],["^1C","shadow/js.js"],["0273d29a26c6414d6326ed34664dcb7e98415b06","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/object/object.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/dom/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@"]]],["^1C","goog/structs/set.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^5R","~$goog.structs.Collection","^5S","~$goog.iter.Iterator"]]],"~:SHADOW-TIMESTAMP",[1635907472000,1635907472000,1635907547000],["^64","node_modules/react/cjs/react.development.js"],["e8091a4577ab6b32c9fa13d5dfc59db052218e1e","4e9614cdc0e2c223ef717009a8fd70c2c8df01cc","754b7a48941975257c8955f6d5e511cb3a878737","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^65","~$module$node_modules$object_assign$index"]]],["^1C","goog/math/long.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","^4V"]]],["^1C","goog/events/listener.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^5E","^5?"]]],["^1C","goog/html/trustedresourceurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","~$goog.fs.blob","^4J","~$goog.html.SafeScript","~$goog.html.trustedtypes","^4L","^4M","^4N","^4O"]]],["^1C","goog/debug/tracer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4@","~$goog.debug","~$goog.debug.Logger","~$goog.iter","^5O","^5S","~$goog.structs.SimplePool"]]],["^1C","goog/events/listenermap.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^5F","^4H","^5B","^5?","^5E"]]],["^1C","goog/events/eventid.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","taoensso/truss.cljs"],["ef3f595da76cbcbe40124ee0a858b7ca635d30f2","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","~$taoensso.truss.impl"]]],["^1C","goog/string/internal.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/events/eventwrapper.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.events.EventHandler","~$goog.events.ListenableType"]]],["^1C","com/fulcrologic/fulcro/algorithms/merge.cljc"],["1caf5ece14d08c1a1f2d6dbda6366e56e941c356","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^V","^X","^P","^R","^Z","^14","^Q","^T","^12"]]],["^1C","edn_query_language/core.cljc"],["89cd2ff9787f6dfcb81506253473dfa9b27d718a","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^B"]]],["^1C","goog/functions/functions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/html/safestyle.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4@","~$goog.html.SafeUrl","^4N","^4O","^4I"]]],["^1C","goog/dom/safe.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^6=","~$goog.html.SafeStyle","^6F","^4K","~$goog.html.uncheckedconversions","^4N","^4I"]]],["^1C","expound/paths.cljc"],["f84ecd45aeef38fd6f1c53d8323e6abc5dc5a0e4","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^B","^5Z"]]],["^1C","taoensso/truss/impl.cljs"],["ef3f595da76cbcbe40124ee0a858b7ca635d30f2","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^50"]]],["^1C","clojure/walk.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10"]]],["^1C","goog/useragent/product.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4S","^4U","^4G"]]],["^1C","goog/net/eventtype.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/structs/map.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^69","~$goog.iter.StopIteration"]]],["^1C","goog/net/xhriopool.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^56","~$goog.structs.PriorityPool","^5S"]]],["^1C","goog/html/safehtml.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4@","~$goog.dom.TagName","~$goog.dom.tags","^6=","^6J","~$goog.html.SafeStyleSheet","^6F","^4K","^6>","^4L","^4M","^4S","^4H","^4N","^4O","^4I"]]],["^1C","goog/dom/tags.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4H"]]],["^1C","goog/math/size.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/structs/queue.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?"]]],["^1C","goog/labs/useragent/engine.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4=","^4>"]]],["^1C","goog/fs/blob.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?"]]],["^1C","taoensso/timbre/appenders/core.cljs"],["daf6b8826cb16aed7fb3e0dd7a5c5266d2a53854","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4E","~$taoensso.encore"]]],["^1C","cljs/reader.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4H","^5K","^52","^54"]]],["^1C","goog/dom/dom.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4@","~$goog.dom.BrowserFeature","~$goog.dom.NodeType","^6N","~$goog.dom.safe","^6I","^6K","~$goog.math.Coordinate","~$goog.math.Size","^4H","^4>","^4N","~$goog.string.Unicode","^4G"]]],["^1C","com/fulcrologic/fulcro/components.cljc"],["1caf5ece14d08c1a1f2d6dbda6366e56e941c356","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4H","~$cljsjs.react","^Q","^B","^T","^6Q","~$clojure.walk","^4E","^14","^Z","^P","^5W","^50"]]],["^1C","goog/asserts/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.debug.Error","^6S"]]],["^1C","goog/uri/uri.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4@","^4>","^5R","^5S","^5T","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1C","goog/net/errorcode.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/i18n/bidi.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^64","node_modules/object-assign/index.js"],["e8091a4577ab6b32c9fa13d5dfc59db052218e1e","4e9614cdc0e2c223ef717009a8fd70c2c8df01cc","519ffd5a4c91b67302cc9947b794966d629860cd","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^65"]]],["^1C","goog/debug/errorhandler.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^60","^4@","^6?","~$goog.debug.EntryPointMonitor","^6Z","~$goog.debug.Trace"]]],["^1C","goog/disposable/idisposable.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/promise/promise.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4C","^4@","^5<","~$goog.async.run","^4[","^6Z","~$goog.promise.Resolver"]]],["^1C","cljs/spec/alpha.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4H","^6Y","~$cljs.spec.gen.alpha","^4E"]]],["^1C","goog/fs/url.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/base.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",[]]],["^1C","goog/json/hybrid.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","~$goog.json"]]],["^1C","goog/structs/structs.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4H"]]],["^1C","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^5H","^4E","~$cljs.tools.reader.impl.inspect"]]],["^1C","cljsjs/react.cljs"],["4323f8e603a952cae34c4c6db04141e97928434f","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","~$module$node_modules$react$index"]]],["^1C","clojure/string.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4>","^54"]]],["^1C","com/fulcrologic/fulcro/algorithms/tempid.cljc"],["1caf5ece14d08c1a1f2d6dbda6366e56e941c356","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^T","^6Y"]]],["^1C","goog/structs/pool.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^60","~$goog.structs.Queue","~$goog.structs.Set"]]],["^64","node_modules/react/cjs/react.production.min.js"],["e8091a4577ab6b32c9fa13d5dfc59db052218e1e","4e9614cdc0e2c223ef717009a8fd70c2c8df01cc","0a81b45abe33f0ad39b726512604018f94261db9","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^65","^6;"]]],["^1C","goog/net/httpstatus.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/structs/heap.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4H","~$goog.structs.Node"]]],["^1C","goog/debug/entrypointregistry.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@"]]],["^1C","goog/string/string.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^6T","^6K","^4N","^4I"]]],["^1C","goog/reflect/reflect.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/labs/useragent/util.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4I"]]],["^1C","expound/printer.cljc"],["f84ecd45aeef38fd6f1c53d8323e6abc5dc5a0e4","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4E","^B","^@","^50","^5Z","^5[","^4R","^6Y","^53","^4>"]]],["^1C","goog/debug/debug.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","~$goog.debug.errorcontext","^4G"]]],["^1C","goog/string/stringbuffer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/math/coordinate.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.math"]]],["^1C","goog/debug/errorcontext.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^5I","^4>","^54"]]],["^1C","goog/iter/iter.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4?","^4@","^6H","^7="]]],["^1C","goog/async/nexttick.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^5=","~$goog.dom","^6N","^6H","^4S","^4T"]]],["^1C","goog/html/uncheckedconversions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","^6I","^6=","^6J","^6P","^6F","^4K","^4N","^4I","^4L"]]],["^1C","goog/debug/logger.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^6?","^5O","~$goog.log.Level","~$goog.log.LogRecord","~$goog.log.Logger"]]],["^1C","goog/events/event.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^60","^5B"]]],["^1C","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^5G","^5H","^5I"]]],["^1C","goog/events/eventhandler.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^60","^55","^4H","^61","^5B","^4B","^5D"]]],["^1C","goog/dom/htmlelement.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","cljs/core.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","~$goog.math.Long","~$goog.math.Integer","^4>","^4H","^4?","^4D","^54"]]],["^1C","goog/html/safescript.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4N","^4O","^6>","^4@"]]],["^1C","goog/log/log.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","^6?"]]],["^1C","goog/html/safestylesheet.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4N","^6J","^4O","^4?","^4H","^4@","^4I"]]],["^1C","goog/structs/collection.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/events/browserevent.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^6?","^4F","^61","~$goog.events.EventType","^4V","^4G"]]],["^1C","goog/math/integer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4V"]]],["^1C","goog/structs/node.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/structs/simplepool.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^60"]]],["^1C","goog/dom/browserfeature.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4G"]]],["^1C","clojure/set.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10"]]],["^1C","goog/uri/utils.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","^4>"]]],["^1C","goog/string/const.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","^4O"]]],["^1C","taoensso/timbre.cljs"],["daf6b8826cb16aed7fb3e0dd7a5c5266d2a53854","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^4E","^6Q","~$taoensso.timbre.appenders.core"]]],["^1C","goog/json/json.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/events/listenable.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^5B","^5C"]]],["^1C","goog/net/xmlhttpfactory.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^5U"]]],["^1C","com/fulcrologic/fulcro/algorithms/denormalize.cljc"],["1caf5ece14d08c1a1f2d6dbda6366e56e941c356","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^10","^T","^50","^Q"]]],["^1C","goog/net/xmlhttp.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","~$goog.net.WrapperXmlHttpFactory","^5V","^5U"]]],["^1C","goog/net/xhrlike.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11"]]],["^1C","goog/crypt/base64.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^48",["^ ","^49",null,"^4:",["^G",[]],"^4;",["^11","^4@","^4P","^4>","^4G","~$goog.userAgent.product"]]]]],"~:clj-info",["^ ","jar:file:/Users/nitin/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1635907474000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/pprint.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/tagged_literals.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/instant.clj",1617991017000,"jar:file:/Users/nitin/.m2/repository/org/clojure/spec.alpha/0.2.194/spec.alpha-0.2.194.jar!/clojure/spec/alpha.clj",1617990988000,"jar:file:/Users/nitin/.m2/repository/com/fulcrologic/fulcro/3.4.14/fulcro-3.4.14.jar!/com/fulcrologic/fulcro/algorithms/denormalize.cljc",1635907474000,"jar:file:/Users/nitin/.m2/repository/expound/expound/0.8.9/expound-0.8.9.jar!/expound/alpha.cljc",1621233320000,"jar:file:/Users/nitin/.m2/repository/expound/expound/0.8.9/expound-0.8.9.jar!/expound/problems.cljc",1621233320000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/set.clj",1617991017000,"jar:file:/Users/nitin/.m2/repository/org/clojure/spec.alpha/0.2.194/spec.alpha-0.2.194.jar!/clojure/spec/gen/alpha.clj",1617990988000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/pprint.clj",1617991017000,"jar:file:/Users/nitin/.m2/repository/com/taoensso/truss/1.5.0/truss-1.5.0.jar!/taoensso/truss.clj",1635907472000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64_vlq.clj",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/walk.clj",1617991017000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/env.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/com/fulcrologic/fulcro/3.4.14/fulcro-3.4.14.jar!/com/fulcrologic/fulcro/algorithms/lookup.cljc",1635907474000,"jar:file:/Users/nitin/.m2/repository/com/taoensso/timbre/4.10.0/timbre-4.10.0.jar!/taoensso/timbre/appenders/core.clj",1635907473000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/util.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader.clj",1635907474000,"jar:file:/Users/nitin/.m2/repository/com/fulcrologic/guardrails/0.0.12/guardrails-0.0.12.jar!/com/fulcrologic/guardrails/core.cljc",1635907473000,"jar:file:/Users/nitin/.m2/repository/com/fulcrologic/fulcro/3.4.14/fulcro-3.4.14.jar!/com/fulcrologic/fulcro/algorithms/do_not_use.cljc",1635907474000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/instant.clj",1635907547000,"jar:file:/Users/nitin/.m2/repository/io/aviso/pretty/0.1.33/pretty-0.1.33.jar!/io/aviso/exception.clj",1635907472000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/spec/alpha.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/com/fulcrologic/guardrails/0.0.12/guardrails-0.0.12.jar!/com/fulcrologic/guardrails/utils.cljc",1635907473000,"jar:file:/Users/nitin/.m2/repository/com/taoensso/timbre/4.10.0/timbre-4.10.0.jar!/taoensso/timbre.clj",1635907473000,"jar:file:/Users/nitin/.m2/repository/io/aviso/pretty/0.1.33/pretty-0.1.33.jar!/io/aviso/columns.clj",1635907472000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/java/io.clj",1617991017000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/string.clj",1617991017000,"jar:file:/Users/nitin/.m2/repository/io/aviso/pretty/0.1.33/pretty-0.1.33.jar!/io/aviso/writer.clj",1635907472000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/externs.clj",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1635907474000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/edn-query-language/eql/1.0.0/eql-1.0.0.jar!/edn_query_language/core.cljc",1635907473000,"jar:file:/Users/nitin/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1635907474000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map.clj",1635907547000,"jar:file:/Users/nitin/.m2/repository/com/taoensso/encore/2.120.0/encore-2.120.0.jar!/taoensso/encore.clj",1635907472000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/core.clj",1617991017000,"jar:file:/Users/nitin/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/default_data_readers.clj",1635907474000,"jar:file:/Users/nitin/.m2/repository/expound/expound/0.8.9/expound-0.8.9.jar!/expound/ansi.cljc",1621233320000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/js_deps.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/edn.clj",1635907474000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/edn.clj",1617991017000,"jar:file:/Users/nitin/.m2/repository/expound/expound/0.8.9/expound-0.8.9.jar!/expound/util.cljc",1621233320000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/compiler.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/com/taoensso/truss/1.5.0/truss-1.5.0.jar!/taoensso/truss/impl.clj",1635907472000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/reader.clj",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/core.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes/and_or.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1635907474000,"jar:file:/Users/nitin/.m2/repository/io/aviso/pretty/0.1.33/pretty-0.1.33.jar!/io/aviso/ansi.clj",1635907472000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/impl.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/com/fulcrologic/fulcro/3.4.14/fulcro-3.4.14.jar!/com/fulcrologic/fulcro/components.cljc",1635907474000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/main.clj",1617991017000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/spec/gen/alpha.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/data.json/2.4.0/data.json-2.4.0.jar!/clojure/data/json.clj",1635907472000,"jar:file:/Users/nitin/.m2/repository/expound/expound/0.8.9/expound-0.8.9.jar!/expound/paths.cljc",1621233320000,"jar:file:/Users/nitin/.m2/repository/expound/expound/0.8.9/expound-0.8.9.jar!/expound/printer.cljc",1621233320000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64.clj",1635907547000,"jar:file:/Users/nitin/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes.cljc",1635907547000,"jar:file:/Users/nitin/.m2/repository/com/fulcrologic/guardrails/0.0.12/guardrails-0.0.12.jar!/com/fulcrologic/guardrails/config.cljc",1635907473000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","Various algorithms that are used for merging trees of data into a normalized Fulcro database.","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",1,"^9",5,"^:",1,"^;",44],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D"],"^E",null,"^F",["^G",[]],"^H","^I","^J",["^ "],"^M",null,"^N",["^ ","^O","^P","^Q","^Q","^R","^R","^S","^T","^U","^V","^W","^X","^Y","^Q","^Z","^Z","^[","^R","^10","^10","^11","^11","^V","^V","^12","^12","^13","^14","^P","^P","^X","^X","^T","^T","^15","^Z","^16","^12","^14","^14"],"^17",["^G",["^18"]],"~:shadow/js-access-global",["^G",["Error"]],"^19",null,"~:defs",["^ ","~$merge*",["^ ","~:protocol-inline",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",301,"^9",7,"^:",301,"^;",13,"~:arglists",["^1<",["~$quote",["^1<",[["~$state-map","~$query","~$result-tree"],["^95","^96","^97","~$options"]]]]],"^6","Merge the query-result of a query using Fulcro's standard merge and normalization logic.\n\n  Typically used on the state atom as:\n\n  ```\n  (swap! state merge* query-result query)\n  ```\n\n  - `state-map` - The normalized database.\n  - `query` - The query that was used to obtain the query-result. This query will be treated relative to the root of the database.\n  - `tree` - The query-result to merge (a map).\n\n  The options is currently doing nothing. If you want to sweep unreturned data use `merge/mark-missing` on your data tree\n  before calling this.\n\n  See `merge-component` and `merge-component!` for possibly more appropriate functions for your task.\n\n  Returns the new normalized database.","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",4,"~:max-fixed-arity",4,"~:method-params",[["^95","^96","^97"],["^95","^96","^97","^98"]],"^93",["^1<",[["^95","^96","^97"],["^95","^96","^97","^98"]]],"~:arglists-meta",["^1<",[null,null]]]],"^H","^3T","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",13,"^99",["^ ","^9:",false,"^9;",4,"^9<",4,"^9=",[["^95","^96","^97"],["^95","^96","^97","^98"]],"^93",["^1<",[["^95","^96","^97"],["^95","^96","^97","^98"]]],"^9>",["^1<",[null,null]]],"^9=",[["^95","^96","^97"],["^95","^96","^97","^98"]],"~:protocol-impl",null,"^9;",4,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"~:methods",[["^ ","^9;",3,"^9:",false,"~:tag","~$any"],["^ ","^9;",4,"^9:",false,"^9A",["^G",[null,"^9B"]]]],"^8",301,"^:",301,"^9<",4,"~:fn-var",true,"^93",["^1<",[["^95","^96","^97"],["^95","^96","^97","^98"]]],"^6","Merge the query-result of a query using Fulcro's standard merge and normalization logic.\n\n  Typically used on the state atom as:\n\n  ```\n  (swap! state merge* query-result query)\n  ```\n\n  - `state-map` - The normalized database.\n  - `query` - The query that was used to obtain the query-result. This query will be treated relative to the root of the database.\n  - `tree` - The query-result to merge (a map).\n\n  The options is currently doing nothing. If you want to sweep unreturned data use `merge/mark-missing` on your data tree\n  before calling this.\n\n  See `merge-component` and `merge-component!` for possibly more appropriate functions for your task.\n\n  Returns the new normalized database."],"~$merge-alternate-union-elements!",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",478,"^9",7,"^:",478,"^;",38,"^93",["^1<",["^94",["^1<",[["~$app","~$root-component"]]]]],"^6","Walks the query and initial state of root-component and merges the alternate sides of unions with initial state into\n  the application state database. See also `merge-alternate-union-elements`, which can be used on a state map and\n  is handy for server-side rendering. This function side-effects on your app, and returns nothing."],"^H","^2U","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",38,"^9=",["^1<",[["^9E","^9F"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",478,"~:ret-tag","^9B","^:",478,"^9<",2,"^9C",true,"^93",["^1<",["^94",["^1<",[["^9E","^9F"]]]]],"^6","Walks the query and initial state of root-component and merges the alternate sides of unions with initial state into\n  the application state database. See also `merge-alternate-union-elements`, which can be used on a state map and\n  is handy for server-side rendering. This function side-effects on your app, and returns nothing."],"~$sweep-merge",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",198,"^9",7,"^:",198,"^;",18,"^93",["^1<",["^94",["^1<",[["~$target","~$source"]]]]],"^6","Do a recursive merge of source into target (both maps), but remove any target data that is marked as missing in the response.\n\n  Requires that the `source` has been marked via `mark-missing`.\n\n  The missing marker is generated in the source when something has been asked for in the query, but had no value in the\n  response. This allows us to correctly remove 'empty' data from the database without accidentally removing something\n  that may still exist on the server (in truth we don't know its status, since it wasn't asked for, but we leave\n  it as our 'best guess')."],"^H","^3N","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",18,"^9=",["^1<",[["^9I","^9J"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",198,"^9G",["^G",[null,"^9B"]],"^:",198,"^9<",2,"^9C",true,"^93",["^1<",["^94",["^1<",[["^9I","^9J"]]]]],"^6","Do a recursive merge of source into target (both maps), but remove any target data that is marked as missing in the response.\n\n  Requires that the `source` has been marked via `mark-missing`.\n\n  The missing marker is generated in the source when something has been asked for in the query, but had no value in the\n  response. This allows us to correctly remove 'empty' data from the database without accidentally removing something\n  that may still exist on the server (in truth we don't know its status, since it wasn't asked for, but we leave\n  it as our 'best guess')."],"~$merge!",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",364,"^9",7,"^:",364,"^;",13,"^93",["^1<",["^94",["^1<",[["^9E","~$data-tree","^96"],["^9E","^9L","^96","^98"]]]]],"^6","Merge an arbitrary data-tree that conforms to the shape of the given query using Fulcro's\n  standard merge and normalization logic.\n\n  app - A fulcro application to merge into.\n  query - A query, derived from components, that can be used to normalized a tree of data.\n  data-tree - A tree of data that matches the nested shape of query.\n\n  The options map currently does nothing. If you want to remove unreturned data use `merge/mark-missing` on the\n  data tree before merging and a sweep will automatically be done.\n\n  NOTE: This function assumes you are merging against the root of the tree. See\n  `merge-component` and `merge-component!` for relative merging.\n\n  See also `merge*`.","^99",["^ ","^9:",false,"^9;",4,"^9<",4,"^9=",[["^9E","^9L","^96"],["^9E","^9L","^96","^98"]],"^93",["^1<",[["^9E","^9L","^96"],["^9E","^9L","^96","^98"]]],"^9>",["^1<",[null,null]]]],"^H","^3Z","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",13,"^99",["^ ","^9:",false,"^9;",4,"^9<",4,"^9=",[["^9E","^9L","^96"],["^9E","^9L","^96","^98"]],"^93",["^1<",[["^9E","^9L","^96"],["^9E","^9L","^96","^98"]]],"^9>",["^1<",[null,null]]],"^9=",[["^9E","^9L","^96"],["^9E","^9L","^96","^98"]],"^9?",null,"^9;",4,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^9@",[["^ ","^9;",3,"^9:",false,"^9A","^9B"],["^ ","^9;",4,"^9:",false,"^9A",["^G",[null,"^9B","~$clj-nil"]]]],"^8",364,"^:",364,"^9<",4,"^9C",true,"^93",["^1<",[["^9E","^9L","^96"],["^9E","^9L","^96","^98"]]],"^6","Merge an arbitrary data-tree that conforms to the shape of the given query using Fulcro's\n  standard merge and normalization logic.\n\n  app - A fulcro application to merge into.\n  query - A query, derived from components, that can be used to normalized a tree of data.\n  data-tree - A tree of data that matches the nested shape of query.\n\n  The options map currently does nothing. If you want to remove unreturned data use `merge/mark-missing` on the\n  data tree before merging and a sweep will automatically be done.\n\n  NOTE: This function assumes you are merging against the root of the tree. See\n  `merge-component` and `merge-component!` for relative merging.\n\n  See also `merge*`."],"~$union->query",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",61,"^9",8,"^:",61,"^;",20,"~:private",true,"^93",["^1<",["^94",["^1<",[["~$union-query"]]]]],"^6","Turn a union query into a query that attempts to encompass all possible things that might be queried."],"^9O",true,"^H","^36","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",20,"^9=",["^1<",[["^9P"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",61,"^9G",["^G",["~$clj","~$cljs.core/IVector","^9B","~$cljs.core/MetaFn","^9M"]],"^:",61,"^9<",1,"^9C",true,"^93",["^1<",["^94",["^1<",[["^9P"]]]]],"^6","Turn a union query into a query that attempts to encompass all possible things that might be queried."],"~$merge-mutation-joins",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",241,"^9",7,"^:",241,"^;",27,"^93",["^1<",["^94",["^1<",[["~$state","^96","^9L"],["^9U","^96","^9L","^98"]]]]],"^6","Merge all of the mutations that were joined with a query.\n\n  The options currently do nothing. If you want mark/sweep, pre-mark the data-tree with `merge/mark-missing`,\n  and this function will sweep the result.","^99",["^ ","^9:",false,"^9;",4,"^9<",4,"^9=",[["^9U","^96","^9L"],["^9U","^96","^9L","^98"]],"^93",["^1<",[["^9U","^96","^9L"],["^9U","^96","^9L","^98"]]],"^9>",["^1<",[null,null]]]],"^H","^2[","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",27,"^99",["^ ","^9:",false,"^9;",4,"^9<",4,"^9=",[["^9U","^96","^9L"],["^9U","^96","^9L","^98"]],"^93",["^1<",[["^9U","^96","^9L"],["^9U","^96","^9L","^98"]]],"^9>",["^1<",[null,null]]],"^9=",[["^9U","^96","^9L"],["^9U","^96","^9L","^98"]],"^9?",null,"^9;",4,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^9@",[["^ ","^9;",3,"^9:",false,"^9A","^9B"],["^ ","^9;",4,"^9:",false,"^9A",["^G",[null,"^9B"]]]],"^8",241,"^:",241,"^9<",4,"^9C",true,"^93",["^1<",[["^9U","^96","^9L"],["^9U","^96","^9L","^98"]]],"^6","Merge all of the mutations that were joined with a query.\n\n  The options currently do nothing. If you want mark/sweep, pre-mark the data-tree with `merge/mark-missing`,\n  and this function will sweep the result."],"~$mark-missing",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",149,"^9",7,"^:",149,"^;",19,"^93",["^1<",["^94",["^1<",[["~$result","^96"]]]]],"^6","Recursively walk the query and response marking anything that was *asked for* in the query but is *not* in the response as missing.\n  The sweep-merge process (which happens later in the plumbing) uses these markers as indicators to remove any existing\n  data in the target of the merge (i.e. your state database).\n\n  The naive approach to data merging (even recursive) would fail to remove such data.\n\n  Returns the result with missing markers in place (which are then used/removed in a later stage).\n\n  See the Developer Guide section on Fulcro's merge process for more information."],"^H","^1P","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",19,"^9=",["^1<",[["^9W","^96"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",149,"^:",149,"^9<",2,"^9C",true,"^93",["^1<",["^94",["^1<",[["^9W","^96"]]]]],"^6","Recursively walk the query and response marking anything that was *asked for* in the query but is *not* in the response as missing.\n  The sweep-merge process (which happens later in the plumbing) uses these markers as indicators to remove any existing\n  data in the target of the merge (i.e. your state database).\n\n  The naive approach to data merging (even recursive) would fail to remove such data.\n\n  Returns the result with missing markers in place (which are then used/removed in a later stage).\n\n  See the Developer Guide section on Fulcro's merge process for more information."],"~$nilify-not-found",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",36,"^9",7,"^:",36,"^;",23,"^93",["^1<",["^94",["^1<",[["~$x"]]]]],"^6","Given x, return x value unless it's ::not-found (the mark/sweep missing marker), in which case it returns nil.\n\n  This is useful when you are pre-processing a tree that has been marked for missing data sweep (see `mark-missing`),\n  but has not yet been swept. This is basically the same as a `nil?` check in this circumstance since the given\n  value will be removed after the final sweep."],"^H","^1S","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",23,"^9=",["^1<",[["~$x"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",36,"^9G",["^G",[null,"^9M"]],"^:",36,"^9<",1,"^9C",true,"^93",["^1<",["^94",["^1<",[["~$x"]]]]],"^6","Given x, return x value unless it's ::not-found (the mark/sweep missing marker), in which case it returns nil.\n\n  This is useful when you are pre-processing a tree that has been marked for missing data sweep (see `mark-missing`),\n  but has not yet been swept. This is basically the same as a `nil?` check in this circumstance since the given\n  value will be removed after the final sweep."],"~$pre-merge-transform",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",231,"^9",7,"^:",231,"^;",26,"^93",["^1<",["^94",["^1<",[["^9U"],["^9U","^98"]]]]],"^6","Transform function that modifies data using component pre-merge hook.","^99",["^ ","^9:",false,"^9;",2,"^9<",2,"^9=",[["^9U"],["^9U","^98"]],"^93",["^1<",[["^9U"],["^9U","^98"]]],"^9>",["^1<",[null,null]]]],"^H","^3=","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",26,"^99",["^ ","^9:",false,"^9;",2,"^9<",2,"^9=",[["^9U"],["^9U","^98"]],"^93",["^1<",[["^9U"],["^9U","^98"]]],"^9>",["^1<",[null,null]]],"^9=",[["^9U"],["^9U","^98"]],"^9?",null,"^9;",2,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^9@",[["^ ","^9;",1,"^9:",false,"^9A","^9B"],["^ ","^9;",2,"^9:",false,"^9A","~$function"]],"^8",231,"^:",231,"^9<",2,"^9C",true,"^93",["^1<",[["^9U"],["^9U","^98"]]],"^6","Transform function that modifies data using component pre-merge hook."],"~$merge-ident",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",266,"^9",7,"^:",266,"^;",18,"^93",["^1<",["^94",["^1<",[["~$app-state","~$ident","~$props"]]]]]],"^H","^2J","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",18,"^9=",["^1<",[["^:0","^:1","^:2"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",266,"^9G",["^G",["^9Q","^9B"]],"^:",266,"^9<",3,"^9C",true,"^93",["^1<",["^94",["^1<",[["^:0","^:1","^:2"]]]]]],"~$is-ui-query-fragment?",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",23,"^9",7,"^:",23,"^;",28,"^93",["^1<",["^94",["^1<",[["~$kw"]]]]],"^6","Check the given keyword to see if it is in the :ui namespace."],"^H","^23","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",28,"^9=",["^1<",[["^:4"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",23,"^9G",["^G",["^9Q","^9R","^9B","^9S","^9M"]],"^:",23,"^9<",1,"^9C",true,"^93",["^1<",["^94",["^1<",[["^:4"]]]]],"^6","Check the given keyword to see if it is in the :ui namespace."],"~$not-found?",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",29,"^9",7,"^:",29,"^;",17,"^93",["^1<",["^94",["^1<",[["^:2","~$k"]]]]],"^6","Returns true if the `k` in `props` is the sweep-merge not-found marker. This marker appears\n  *during* merge, and can affect `:pre-merge` processing, since the data-tree will have these\n  markers when the given data is missing."],"^H","^2E","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",17,"^9=",["^1<",[["^:2","~$k"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",29,"^9G","~$boolean","^:",29,"^9<",2,"^9C",true,"^93",["^1<",["^94",["^1<",[["^:2","~$k"]]]]],"^6","Returns true if the `k` in `props` is the sweep-merge not-found marker. This marker appears\n  *during* merge, and can affect `:pre-merge` processing, since the data-tree will have these\n  markers when the given data is missing."],"~$component-merge-query",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",329,"^9",7,"^:",329,"^;",28,"^93",["^1<",["^94",["^1<",[["^95","~$component","~$object-data"]]]]],"^6","Calculates the query that can be used to pull (or merge) a component with an ident\n  to/from a normalized app database. Requires a tree of data that represents the instance of\n  the component in question (e.g. ident will work on it)"],"^H","^1Y","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",28,"^9=",["^1<",[["^95","^:8","^:9"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",329,"^9G","^9R","^:",329,"^9<",3,"^9C",true,"^93",["^1<",["^94",["^1<",[["^95","^:8","^:9"]]]]],"^6","Calculates the query that can be used to pull (or merge) a component with an ident\n  to/from a normalized app database. Requires a tree of data that represents the instance of\n  the component in question (e.g. ident will work on it)"],"~$merge-alternate-union-elements",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",467,"^9",7,"^:",467,"^;",37,"^93",["^1<",["^94",["^1<",[["^95","^9F"]]]]],"^6","Just like merge-alternate-union-elements!, but usable from within mutations and on server-side rendering. Ensures\n  that when a component has initial state it will end up in the state map, even if it isn't currently in the\n  initial state of the union component (which can only point to one at a time)."],"^H","^25","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",37,"^9=",["^1<",[["^95","^9F"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",467,"^9G","^9B","^:",467,"^9<",2,"^9C",true,"^93",["^1<",["^94",["^1<",[["^95","^9F"]]]]],"^6","Just like merge-alternate-union-elements!, but usable from within mutations and on server-side rendering. Ensures\n  that when a component has initial state it will end up in the state map, even if it isn't currently in the\n  initial state of the union component (which can only point to one at a time)."],"~$remove-ident*",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",14,"^9",7,"^:",14,"^;",20,"^93",["^1<",["^94",["^1<",[["^95","^:1","~$path-to-idents"]]]]],"^6","Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations."],"^H","^3P","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",20,"^9=",["^1<",[["^95","^:1","^:<"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",14,"^9G",["^G",["^9Q","^9B"]],"^:",14,"^9<",3,"^9C",true,"^93",["^1<",["^94",["^1<",[["^95","^:1","^:<"]]]]],"^6","Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations."],"~$component-pre-merge",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",221,"^9",8,"^:",221,"^;",27,"^9O",true,"^93",["^1<",["^94",["^1<",[["~$class","^96","^9U","~$data","^98"]]]]]],"^9O",true,"^H","^3W","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",27,"^9=",["^1<",[["^:>","^96","^9U","^:?","^98"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",221,"^9G",["^G",[null,"^9B","^9M"]],"^:",221,"^9<",5,"^9C",true,"^93",["^1<",["^94",["^1<",[["^:>","^96","^9U","^:?","^98"]]]]]],"~$sweep-one",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",166,"^9",8,"^:",166,"^;",17,"^9O",true,"^93",["^1<",["^94",["^1<",[["~$m"]]]]],"^6","Remove not-found keys from m (non-recursive). `m` can be a map (sweep the values) or vector (run sweep-one on each entry)."],"^9O",true,"^H","^32","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",17,"^9=",["^1<",[["~$m"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",166,"^9G",["^G",[null,"^9Q","^9B","^9S","^9M"]],"^:",166,"^9<",1,"^9C",true,"^93",["^1<",["^94",["^1<",[["~$m"]]]]],"^6","Remove not-found keys from m (non-recursive). `m` can be a map (sweep the values) or vector (run sweep-one on each entry)."],"~$merge-component!",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",428,"^9",7,"^:",428,"^;",23,"^93",["^1<",["^94",["^1<",[["^9E","^:8","^:9","~$&","~$named-parameters"]]]]],"^6","Normalize and merge a (sub)tree of application state into the application using a known UI component's query and ident.\n\n  This utility function obtains the ident of the incoming object-data using the UI component's ident function. Once obtained,\n  it uses the component's query and ident to normalize the data and places the resulting objects in the correct tables.\n  It is also quite common to want those new objects to be linked into lists in other spots in app state, so this function\n  supports optional named parameters for doing this. These named parameters can be repeated as many times as you like in order\n  to place the ident of the new object into other data structures of app state.\n\n  This function honors the data merge story for Fulcro: attributes that are queried for but do not appear in the\n  data will be removed from the application. This function also uses the initial state for the component as a base\n  for merge if there was no state for the object already in the database.\n\n  This function will also trigger re-renders of components that directly render object merged, as well as any components\n  into which you integrate that data via the named-parameters.\n\n  This function is primarily meant to be used from things like server push and setTimeout/setInterval, where you're outside\n  of the normal mutation story. Do not use this function within abstract mutations.\n\n  * `app`: Your application.\n  * `component`: The class of the component that corresponds to the data. Must have an ident.\n  * `object-data`: A map (tree) of data to merge. Will be normalized for you.\n  * `named-parameter`: Post-processing ident integration steps. see `targeting/integrate-ident*`. You may also\n  include `:remove-missing? true/false` to indicate that data that is missing for the component's query\n  should be removed from app state.\n\n  Any keywords that appear in ident integration steps will be added to the re-render queue.\n\n  See also `fulcro.client.primitives/merge!`.\n  ","^99",["^ ","^9:",true,"^9;",3,"^9<",3,"^9=",[["^1<",["^9E","^:8","^:9","^:B"]]],"^93",["^1<",[["^9E","^:8","^:9","~$&","^:B"]]],"^9>",["^1<",[null]]]],"^H","^33","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",23,"^99",["^ ","^9:",true,"^9;",3,"^9<",3,"^9=",[["^1<",["^9E","^:8","^:9","^:B"]]],"^93",["^1<",[["^9E","^:8","^:9","~$&","^:B"]]],"^9>",["^1<",[null]]],"^9=",[["^1<",["^9E","^:8","^:9","^:B"]]],"^9?",null,"^9;",3,"^9>",["^1<",[null]],"^9",1,"^9:",true,"^9@",[["^ ","^9;",3,"^9:",true,"^9A",["^G",["^9B","^9M"]]]],"^8",428,"^9G","^9B","^:",428,"^9<",3,"^9C",true,"^93",["^1<",[["^9E","^:8","^:9","~$&","^:B"]]],"^6","Normalize and merge a (sub)tree of application state into the application using a known UI component's query and ident.\n\n  This utility function obtains the ident of the incoming object-data using the UI component's ident function. Once obtained,\n  it uses the component's query and ident to normalize the data and places the resulting objects in the correct tables.\n  It is also quite common to want those new objects to be linked into lists in other spots in app state, so this function\n  supports optional named parameters for doing this. These named parameters can be repeated as many times as you like in order\n  to place the ident of the new object into other data structures of app state.\n\n  This function honors the data merge story for Fulcro: attributes that are queried for but do not appear in the\n  data will be removed from the application. This function also uses the initial state for the component as a base\n  for merge if there was no state for the object already in the database.\n\n  This function will also trigger re-renders of components that directly render object merged, as well as any components\n  into which you integrate that data via the named-parameters.\n\n  This function is primarily meant to be used from things like server push and setTimeout/setInterval, where you're outside\n  of the normal mutation story. Do not use this function within abstract mutations.\n\n  * `app`: Your application.\n  * `component`: The class of the component that corresponds to the data. Must have an ident.\n  * `object-data`: A map (tree) of data to merge. Will be normalized for you.\n  * `named-parameter`: Post-processing ident integration steps. see `targeting/integrate-ident*`. You may also\n  include `:remove-missing? true/false` to indicate that data that is missing for the component's query\n  should be removed from app state.\n\n  Any keywords that appear in ident integration steps will be added to the re-render queue.\n\n  See also `fulcro.client.primitives/merge!`.\n  "],"~$sweep",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",180,"^9",7,"^:",180,"^;",12,"^93",["^1<",["^94",["^1<",[["~$m"]]]]],"^6","Remove all of the not-found keys (recursively) from m, stopping at marked leaves (if present). Requires `m`\n  to have been pre-marked via `mark-missing`."],"^H","^1O","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",12,"^9=",["^1<",[["~$m"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",180,"^9G",["^G",[null,"^9Q","^9B","^9S","^9M"]],"^:",180,"^9<",1,"^9C",true,"^93",["^1<",["^94",["^1<",[["~$m"]]]]],"^6","Remove all of the not-found keys (recursively) from m, stopping at marked leaves (if present). Requires `m`\n  to have been pre-marked via `mark-missing`."],"~$merge-component",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",387,"^9",7,"^:",387,"^;",22,"^93",["^1<",["^94",["^1<",[["^95","^:8","~$component-data","~$&","^:B"]]]]],"^6","Given a state map of the application database, a component, and a tree of component-data: normalizes\n   the tree of data and merges the component table entries into the state, returning a new state map.\n\n   Since there is not an implied root, the component itself won't be linked into your graph (though it will\n   remain correctly linked for its own consistency).\n\n   * `state-map` - The normalized database\n   * `component` - A component class\n   * `component-data` - A tree of data that matches the shape of the component's query.\n   * `named-parameters` - Parameters from `targeting/integrate-ident*` that will let you link the merged component into the graph.\n   Named parameters may also include `:remove-missing?`, which will remove things that are queried for but do\n   not appear in the data from the state.\n\n   See also targeting/integrate-ident*, and merge/merge-component!","^99",["^ ","^9:",true,"^9;",3,"^9<",3,"^9=",[["^1<",["^95","^:8","^:E","^:B"]]],"^93",["^1<",[["^95","^:8","^:E","~$&","^:B"]]],"^9>",["^1<",[null]]]],"^H","^1V","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",22,"^99",["^ ","^9:",true,"^9;",3,"^9<",3,"^9=",[["^1<",["^95","^:8","^:E","^:B"]]],"^93",["^1<",[["^95","^:8","^:E","~$&","^:B"]]],"^9>",["^1<",[null]]],"^9=",[["^1<",["^95","^:8","^:E","^:B"]]],"^9?",null,"^9;",3,"^9>",["^1<",[null]],"^9",1,"^9:",true,"^9@",[["^ ","^9;",3,"^9:",true,"^9A",["^G",[null,"^9Q","^9M"]]]],"^8",387,"^9G","^9B","^:",387,"^9<",3,"^9C",true,"^93",["^1<",[["^95","^:8","^:E","~$&","^:B"]]],"^6","Given a state map of the application database, a component, and a tree of component-data: normalizes\n   the tree of data and merges the component table entries into the state, returning a new state map.\n\n   Since there is not an implied root, the component itself won't be linked into your graph (though it will\n   remain correctly linked for its own consistency).\n\n   * `state-map` - The normalized database\n   * `component` - A component class\n   * `component-data` - A tree of data that matches the shape of the component's query.\n   * `named-parameters` - Parameters from `targeting/integrate-ident*` that will let you link the merged component into the graph.\n   Named parameters may also include `:remove-missing?`, which will remove things that are queried for but do\n   not appear in the data from the state.\n\n   See also targeting/integrate-ident*, and merge/merge-component!"],"~$sift-idents",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",269,"^9",8,"^:",269,"^;",19,"^9O",true,"^93",["^1<",["^94",["^1<",[["~$res"]]]]]],"^9O",true,"^H","^34","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",19,"^9=",["^1<",[["^:G"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",269,"^9G","^9R","^:",269,"^9<",1,"^9C",true,"^93",["^1<",["^94",["^1<",[["^:G"]]]]]],"~$leaf?",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",52,"^9",8,"^:",52,"^;",13,"^9O",true,"^93",["^1<",["^94",["^1<",[["^:?"]]]]],"^6","Returns true iff the given data is marked as a leaf in the result (according to the query). Requires pre-marking."],"^9O",true,"^H","^3J","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",13,"^9=",["^1<",[["^:?"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",52,"^9G","^:6","^:",52,"^9<",1,"^9C",true,"^93",["^1<",["^94",["^1<",[["^:?"]]]]],"^6","Returns true iff the given data is marked as a leaf in the result (according to the query). Requires pre-marking."],"~$merge-idents",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",282,"^9",7,"^:",282,"^;",19,"^93",["^1<",["^94",["^1<",[["~$tree","^96","~$refs","^98"]]]]],"^6","Merge the given `refs` (a map from ident to props), query (a query that contains ident-joins), and tree:\n\n  returns a new tree with the data merged into the proper ident-based tables."],"^H","^3U","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",19,"^9=",["^1<",[["^:J","^96","^:K","^98"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",282,"^:",282,"^9<",4,"^9C",true,"^93",["^1<",["^94",["^1<",[["^:J","^96","^:K","^98"]]]]],"^6","Merge the given `refs` (a map from ident to props), query (a query that contains ident-joins), and tree:\n\n  returns a new tree with the data merged into the proper ident-based tables."],"~$merge-alternate-unions",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",338,"^9",7,"^:",338,"^;",29,"^93",["^1<",["^94",["^1<",[["~$merge-fn","^9F"]]]]],"^6","Walks the given query and calls (merge-fn parent-union-component union-child-initial-state) for each non-default element of a union that has initial app state.\n  You probably want to use merge-alternate-union-elements[!] on a state map or app."],"^H","^3Q","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",29,"^9=",["^1<",[["^:M","^9F"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",338,"^:",338,"^9<",2,"^9C",true,"^93",["^1<",["^94",["^1<",[["^:M","^9F"]]]]],"^6","Walks the given query and calls (merge-fn parent-union-component union-child-initial-state) for each non-default element of a union that has initial app state.\n  You probably want to use merge-alternate-union-elements[!] on a state map or app."],"~$merge-tree",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",273,"^9",7,"^:",273,"^;",17,"^93",["^1<",["^94",["^1<",[["^9I","^9J"]]]]],"^6","Handle merging incoming data and sweep it of values that are marked missing. This function also ensures that raw\n   mutation join results are ignored (they must be merged via `merge-mutation-joins`)."],"^H","^2?","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",17,"^9=",["^1<",[["^9I","^9J"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",273,"^9G",["^G",[null,"^9B"]],"^:",273,"^9<",2,"^9C",true,"^93",["^1<",["^94",["^1<",[["^9I","^9J"]]]]],"^6","Handle merging incoming data and sweep it of values that are marked missing. This function also ensures that raw\n   mutation join results are ignored (they must be merged via `merge-mutation-joins`)."],"~$as-leaf",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",45,"^9",8,"^:",45,"^;",15,"^9O",true,"^93",["^1<",["^94",["^1<",[["^:?"]]]]],"^6","Returns `data` with meta-data that marks it as a leaf in the result."],"^9O",true,"^H","^3;","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",15,"^9=",["^1<",[["^:?"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",45,"^9G",["^G",[null,"^9Q","^9S","^9M"]],"^:",45,"^9<",1,"^9C",true,"^93",["^1<",["^94",["^1<",[["^:?"]]]]],"^6","Returns `data` with meta-data that marks it as a leaf in the result."],"~$mark-missing-impl",["^ ","^92",null,"^5",["^ ","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^8",66,"^9",7,"^:",66,"^;",24,"^93",["^1<",["^94",["^1<",[["^9W","^96"]]]]]],"^H","^3K","^7","com/fulcrologic/fulcro/algorithms/merge.cljc","^;",24,"^9=",["^1<",[["^9W","^96"]]],"^9?",null,"^9>",["^1<",[null,null]],"^9",1,"^9:",false,"^8",66,"^9G",["^G",[null,"^9B"]],"^:",66,"^9<",2,"^9C",true,"^93",["^1<",["^94",["^1<",[["^9W","^96"]]]]]]],"^1:",["^ ","^10","^10","^S","^T","^W","^X","^X","^X","^T","^T"],"~:cljs.analyzer/constants",["^ ","^17",["^G",["~:state-map","~:tempids","~:children","~:union-key","~:key","~:union-entry","~:else","~:replace","~:remove-missing?","~:prepend","~:fulcro/leaf","~$*","~:append","~:com.fulcrologic.fulcro.algorithms.data-targeting/target","~:type","~:current-normalized","~$_","~:component","~:schedule-render!","~:com.fulcrologic.fulcro.application/state-atom","~:otherwise","~:dispatch-key","~:com.fulcrologic.fulcro.algorithms.merge/temporary-key","~:error","~:com.fulcrologic.fulcro.algorithms.merge/merge","~:query","~:union","~$...","~:auto","~:p","~:com.fulcrologic.fulcro.algorithms.merge/not-found","~:data-tree"]],"~:order",["^;A","^;0","^:X","~$_","^;?","^;8","^;;","~:p","^;@","^:S","^:R","^;4","^;B","^;=","^;5","^;2","^;:","~$*","^:T","^;3","^;9","^:U","^:V","^:W","^;>","^;7","^:Z","^;<","^:Y","^:[","^;1","^;6"]],"^1?",["^ ","^18",["^G",[]]],"^1@",["^ "],"^1A",["^11","^10","^V","^X","^P","^R","^Z","^14","^Q","^T","^12"]],"^L","^I","~:ns-specs",["^ "],"~:ns-spec-vars",["^G",[]],"~:compiler-options",["^47",[["^;F","~:static-fns"],true,["^;F","~:shadow-tweaks"],null,["^;F","~:source-map-inline"],null,["^;F","~:elide-asserts"],false,["^;F","~:optimize-constants"],null,["^;F","^1F"],null,["^;F","~:external-config"],null,["^;F","~:tooling-config"],null,["^;F","~:emit-constants"],null,["^;F","~:load-tests"],null,["^;F","~:form-size-threshold"],null,["^;F","~:data-readers"],null,["^;F","~:infer-externs"],"^;@",["^;F","^1H"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^;F","~:fn-invoke-direct"],null,["^;F","~:source-map"],"/dev/null"]]]